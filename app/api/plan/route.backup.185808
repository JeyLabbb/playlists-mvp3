import { NextResponse } from "next/server";

export async function POST(req) {
  try {
    const { prompt = "", count = 50 } = await req.json().catch(() => ({}));
    const model = process.env.OPENAI_MODEL || "gpt-4o-mini";
    if (!process.env.OPENAI_API_KEY) {
      return NextResponse.json({ error: "openai-key-missing" }, { status: 500 });
    }

    const system = `
Eres un planificador musical. Devuelve SOLO JSON con esta forma:
{
  "candidates": [ { "track": "Titulo", "artist": "Artista" }, ... ],
  "queryTerms": ["palabras", "clave", "útiles", "para Spotify"],
  "isEvent": true|false,
  "count": 120
}
Reglas:
- "candidates" ≥ COUNT + 40% (para cubrir descartes). No inventes títulos raros: usa temas reales conocidos.
- "queryTerms": palabras útiles (festival, ciudad, géneros, años, etc.) para buscar playlists en Spotify si hace falta.
- "isEvent": true si huele a festival/cartel/lineup/edición concreta o información “actual”.
- Respeta el idioma/época/energía si el prompt lo pide.
- SOLO JSON válido. Nada fuera del JSON.
`.trim();

    const user = `COUNT=${Number(count)||50}
PROMPT=${prompt}`.trim();

    const r = await fetch("https://api.openai.com/v1/chat/completions", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${process.env.OPENAI_API_KEY}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        model,
        temperature: 0.3,
        response_format: { type: "json_object" },
        messages: [
          { role: "system", content: system },
          { role: "user", content: user },
        ],
      }),
    });

    const data = await r.json();
    if (!r.ok) return NextResponse.json({ error: "openai", details: data }, { status: r.status });

    const raw = data.choices?.[0]?.message?.content || "{}";
    let plan;
    try { plan = JSON.parse(raw); } catch { plan = {}; }

    const out = {
      candidates: Array.isArray(plan.candidates) ? plan.candidates : [],
      queryTerms: Array.isArray(plan.queryTerms) ? plan.queryTerms.slice(0, 10) : [],
      isEvent: !!plan.isEvent,
      count: Math.max(1, Math.min(Number(plan.count || count || 50), 200))
    };

    return NextResponse.json({ ok: true, plan: out });
  } catch (e) {
    return NextResponse.json({ error: "server", message: String(e?.message || e) }, { status: 500 });
  }
}

export const GET = POST;
