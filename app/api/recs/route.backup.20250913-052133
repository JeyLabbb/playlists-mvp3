import { NextResponse } from "next/server";
import { getToken } from "next-auth/jwt";

/* ---------- utils ---------- */
const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));
const norm = (s)=>String(s||"").toLowerCase()
  .normalize("NFD").replace(/\p{Diacritic}/gu,"").trim();

const BANNED = /\b(aftermovie|after\s*movie|dj\s*set|set\s*live|session|mix(?:tape)?|karaoke|cover(?:s)?|acoustic|instrumental|podcast)\b/i;

function mapTrack(t) {
  if (!t || !t.id) return null;
  return {
    id: t.id,
    name: t.name,
    artists: (t.artists || []).map(a => a.name),
    uri: t.uri,
    open_url: t.external_urls?.spotify || `https://open.spotify.com/track/${t.id}`,
    popularity: typeof t.popularity === "number" ? t.popularity : 0,
  };
}
function dedupeById(list) {
  const out = [];
  const seen = new Set();
  for (const t of list) {
    if (!t || !t.id) continue;
    if (seen.has(t.id)) continue;
    seen.add(t.id);
    out.push(t);
  }
  return out;
}

/* ---------- Spotify helpers ---------- */
async function spotifyGET(accessToken, url) {
  const r = await fetch(url, {
    headers: { Authorization: `Bearer ${accessToken}` },
    cache: "no-store",
  });
  if (!r.ok) throw new Error(`spotify ${r.status}`);
  return r.json();
}

async function searchPlaylists({ accessToken, query, limit = 12 }) {
  const u = new URL("https://api.spotify.com/v1/search");
  u.searchParams.set("q", query);
  u.searchParams.set("type", "playlist");
  u.searchParams.set("limit", String(limit));
  const data = await spotifyGET(accessToken, u.toString());
  return (data?.playlists?.items || []).map(p => ({
    id: p.id,
    name: p.name || "",
    owner: p.owner?.display_name || "",
    tracksTotal: p.tracks?.total || 0,
  }));
}

async function fetchPlaylistTracks({ accessToken, playlistId, max = 500 }) {
  const out = [];
  let url = `https://api.spotify.com/v1/playlists/${playlistId}/tracks?limit=100`;
  while (url && out.length < max) {
    const page = await spotifyGET(accessToken, url);
    for (const it of (page.items || [])) {
      const t = mapTrack(it.track);
      if (t) out.push(t);
    }
    url = page.next;
  }
  return out;
}

async function searchArtistId({ accessToken, name }) {
  const u = new URL("https://api.spotify.com/v1/search");
  u.searchParams.set("q", `artist:"${name.replace(/"/g,"")}"`);
  u.searchParams.set("type", "artist");
  u.searchParams.set("limit", "1");
  const data = await spotifyGET(accessToken, u.toString());
  return data?.artists?.items?.[0]?.id || null;
}
async function fetchArtistTopTracks({ accessToken, artistId }) {
  const u = new URL(`https://api.spotify.com/v1/artists/${artistId}/top-tracks`);
  u.searchParams.set("market", "from_token");
  const data = await spotifyGET(accessToken, u.toString());
  return (data?.tracks || []).map(mapTrack).filter(Boolean);
}

/* ---------- queries festival ---------- */
function buildFestivalQueries(plan) {
  const baseTerms = Array.isArray(plan.queryTerms) && plan.queryTerms.length
    ? plan.queryTerms
    : (Array.isArray(plan.queries) ? plan.queries : []);
  const years = Array.isArray(plan.years) ? plan.years.map(String) : [];
  const raw = String(plan.rawPrompt || "").trim();

  const ensureFestival = (s) => /\bfestival\b/i.test(s) ? s : `${s} festival`;

  const candidates = new Set();
  for (const term of baseTerms.slice(0, 8)) {
    const core = String(term).replace(/\b20\d{2}\b/g, "").trim();
    const variants = [core, `${core} lineup`, `${core} cartel`];
    for (const v of variants) {
      if (years.length) {
        for (const y of years) {
          const w = `${v} ${y}`.trim();
          candidates.add(ensureFestival(w));
          candidates.add(`${ensureFestival(w)} playlist`);
        }
      } else {
        candidates.add(ensureFestival(v));
        candidates.add(`${ensureFestival(v)} playlist`);
      }
    }
  }
  if (raw) {
    const r = raw.replace(/\bplaylist\b/gi,"").trim();
    if (r) {
      candidates.add(ensureFestival(r));
      if (years.length) for (const y of years) candidates.add(`${ensureFestival(r)} ${y}`);
      candidates.add(`${ensureFestival(r)} playlist`);
    }
  }

  return Array.from(candidates)
    .map(s => s.replace(/\s+/g, " ").trim())
    .filter(s => s.length >= 3)
    .slice(0, 20);
}

function broadenFestivalQueries(plan) {
  // Más agresivo: sin “festival”, o solo "lineup/cartel", y combinaciones nombre+ciudad+año
  const base = (plan.queryTerms || plan.queries || []);
  const years = Array.isArray(plan.years) ? plan.years.map(String) : [];
  const raw = String(plan.rawPrompt || "");
  const out = new Set();

  const push = (s)=>{ s=String(s||"").trim(); if(s.length>=3) out.add(s); };

  for (const term of base.slice(0,10)) {
    const core = term.replace(/\b20\d{2}\b/g, "").replace(/\bfestival\b/gi,"").trim();
    push(core);
    push(`${core} lineup`);
    push(`${core} cartel`);
    if (years.length) for (const y of years) { push(`${core} ${y}`); push(`${core} ${y} lineup`); }
  }
  if (raw) {
    const r = raw.replace(/\bfestival\b/gi,"").trim();
    push(r);
    for (const y of years) push(`${r} ${y}`);
  }
  return Array.from(out).slice(0, 20);
}

function nameScore(name, requiredTokens, requiredYears) {
  const n = norm(name);
  if (BANNED.test(n)) return -99;
  if (requiredYears.length && !requiredYears.some(y => n.includes(y))) return -50;
  let score = 0;
  for (const tk of requiredTokens) if (n.includes(tk)) score += 2;
  if (/\bfestival\b/.test(n)) score += 1;
  return score;
}

/* ---------- diversidad ---------- */
function enforceDiversity(tracks, wanted) {
  if (!Array.isArray(tracks) || !tracks.length) return [];
  const capPct = wanted >= 100 ? 0.08 : 0.12; // 8% si pides 100+; si no, 12%
  const cap = Math.max(2, Math.floor(wanted * capPct));

  const byArtist = new Map();
  for (const t of tracks) {
    const a0 = (t.artists && t.artists[0]) ? t.artists[0] : "¿?";
    if (!byArtist.has(a0)) byArtist.set(a0, []);
    byArtist.get(a0).push(t);
  }
  // Orden: artistas más “representativos” primero
  const order = Array.from(byArtist.keys()).sort((a,b)=> (byArtist.get(b).length - byArtist.get(a).length));

  // Dentro de cada artista: ordena por popularidad desc
  for (const arr of byArtist.values()) arr.sort((a,b)=> (b.popularity||0)-(a.popularity||0));

  const result = [];
  const usedByArtist = new Map();
  const usedIds = new Set();

  while (result.length < wanted) {
    let progressed = false;
    for (const artist of order) {
      const used = usedByArtist.get(artist) || 0;
      if (used >= cap) continue;
      const list = byArtist.get(artist);
      while (list && list.length) {
        const t = list.shift();
        if (!t || usedIds.has(t.id)) continue;
        result.push(t); usedIds.add(t.id);
        usedByArtist.set(artist, used + 1);
        progressed = true;
        break;
      }
      if (result.length >= wanted) break;
    }
    if (!progressed) break;
  }

  // Inyección long-tail (si quedaron artistas con 0 presencia)
  if (result.length < wanted) {
    for (const [artist, arr] of byArtist) {
      if ((usedByArtist.get(artist)||0) > 0) continue;
      const t = arr.find(x=>x && !usedIds.has(x.id));
      if (t) { result.push(t); usedIds.add(t.id); }
      if (result.length >= wanted) break;
    }
  }

  return result.slice(0, wanted);
}

/* ---------- FESTIVAL: precisión + diversidad + relleno hasta count ---------- */
async function recsFromFestival({ plan, accessToken, wanted }) {
  // tokens para evaluar nombres
  const tokens = new Set();
  const base = (plan.queryTerms || plan.queries || []).join(" ") || plan.rawPrompt || "";
  for (const w of norm(base).split(/\s+/)) {
    if (!w) continue;
    if (w.length < 3) continue;
    if (/\b(playlist|lineup|cartel|music|musica)\b/.test(w)) continue;
    tokens.add(w);
  }
  const years = Array.isArray(plan.years) ? plan.years.map(String) : [];
  years.forEach(y => tokens.add(y));
  tokens.add("festival");
  const requiredTokens = Array.from(tokens);
  const requiredYears = years;

  // 1) Buscar playlists (primera pasada)
  let q1 = buildFestivalQueries(plan);
  let found = [];
  for (const q of q1) {
    try {
      const pls = await searchPlaylists({ accessToken, query: q, limit: 12 });
      for (const p of pls) {
        const s = nameScore(p.name, requiredTokens, requiredYears);
        if (s >= 4) found.push({ ...p, score: s });
      }
    } catch {}
    if (found.length >= 20) break;
  }

  // Si no hay suficientes, ampliar búsqueda
  if (found.length < 4) {
    const q2 = broadenFestivalQueries(plan);
    for (const q of q2) {
      try {
        const pls = await searchPlaylists({ accessToken, query: q, limit: 12 });
        for (const p of pls) {
          const s = nameScore(p.name, requiredTokens, requiredYears);
          if (s >= 3) found.push({ ...p, score: s });
        }
      } catch {}
      if (found.length >= 24) break;
    }
  }

  if (!found.length) return { tracks: [], debug: { reason: "no-playlists" } };

  found.sort((a,b) =>
    b.score - a.score ||
    b.tracksTotal - a.tracksTotal ||
    a.name.localeCompare(b.name)
  );

  const pick = found.slice(0, Math.min(8, Math.max(4, found.length))); // más playlists para variedad

  // 2) Traer canciones
  const bags = [];
  for (const p of pick) {
    try {
      const items = await fetchPlaylistTracks({ accessToken, playlistId: p.id, max: 600 });
      if (items.length) bags.push({ id: p.id, name: p.name, items });
    } catch {}
  }
  if (!bags.length) return { tracks: [], debug: { reason: "no-tracks" } };

  // 3) Frecuencia por track y por artista
  const trackFreq = new Map(); // id -> {track, count, pop}
  const artistFreq = new Map(); // name -> count(playlists)
  for (const bag of bags) {
    const seenThis = new Set();
    const seenArtistsInBag = new Set();
    for (const t of bag.items) {
      if (!t?.id) continue;
      if (seenThis.has(t.id)) continue;
      seenThis.add(t.id);

      const a0 = (t.artists && t.artists[0]) ? t.artists[0] : null;
      if (a0 && !seenArtistsInBag.has(a0)) {
        artistFreq.set(a0, (artistFreq.get(a0) || 0) + 1);
        seenArtistsInBag.add(a0);
      }

      const cur = trackFreq.get(t.id) || { track: t, count: 0, pop: 0 };
      cur.count += 1;
      cur.pop = Math.max(cur.pop, t.popularity || 0);
      trackFreq.set(t.id, cur);
    }
  }

  // Artistas núcleo = presentes en ≥2 playlists (máx 50)
  const coreArtistsArr = Array.from(artistFreq.entries())
    .filter(([, c]) => c >= 2)
    .sort((a,b)=>b[1]-a[1])
    .map(([name]) => name)
    .slice(0, 50);
  const coreArtists = new Set(coreArtistsArr);

  // Scoring por track
  const scored = Array.from(trackFreq.values()).map(({ track, count, pop }) => {
    const a0 = (track.artists && track.artists[0]) ? track.artists[0] : "";
    const aScore = artistFreq.get(a0) || 0;
    const finalScore = count * 3 + aScore * 1 + pop / 50;
    return { track, a0, count, aScore, finalScore };
  });

  // multi-playlist ≥2 y singles de artista núcleo
  const multi = scored.filter(x => x.count >= 2).sort((a,b)=>b.finalScore-a.finalScore).map(x=>x.track);
  const single = scored.filter(x => x.count === 1 && coreArtists.has(x.a0))
                       .sort((a,b)=>b.finalScore-a.finalScore).map(x=>x.track);

  // 4) Selección con diversidad
  const needMulti = Math.min(multi.length, Math.max(Math.ceil(wanted * 0.85), 10));
  const pickedMulti = enforceDiversity(multi, needMulti);
  const restNeeded = Math.max(0, wanted - pickedMulti.length);
  let pickedRest = enforceDiversity(single, restNeeded);

  let combined = dedupeById([...pickedMulti, ...pickedRest]);

  // 5) Si aún faltan, rellenar con top tracks de artistas núcleo (IDs)
  if (combined.length < wanted && coreArtistsArr.length) {
    const missing = wanted - combined.length;
    const usedIds = new Set(combined.map(t=>t.id));
    const artistIds = [];
    for (const name of coreArtistsArr.slice(0, 20)) {
      try {
        const id = await searchArtistId({ accessToken, name });
        if (id) artistIds.push({ name, id });
      } catch {}
    }
    const extraTT = [];
    for (const a of artistIds) {
      try {
        const tt = await fetchArtistTopTracks({ accessToken, artistId: a.id });
        for (const t of tt) {
          if (!usedIds.has(t.id)) extraTT.push(t);
        }
      } catch {}
      if (extraTT.length >= missing + 40) break; // margen
    }
    if (extraTT.length) {
      const diverseTT = enforceDiversity(extraTT, missing);
      combined = dedupeById([...combined, ...diverseTT]).slice(0, wanted);
    }
  }

  // 6) Si aún faltan, recommendations con semillas de lo ya cogido
  if (combined.length < wanted) {
    const haveIds = new Set(combined.map(t=>t.id));
    const seedTracks = combined.slice(0,5).map(t=>t.id);
    if (seedTracks.length) {
      const u = new URL("https://api.spotify.com/v1/recommendations");
      u.searchParams.set("limit", String(Math.min(100, wanted - combined.length)));
      u.searchParams.set("seed_tracks", seedTracks.join(","));
      try {
        const data = await spotifyGET(accessToken, u.toString());
        const recs = (data?.tracks || []).map(mapTrack).filter(Boolean).filter(t=>!haveIds.has(t.id));
        const diverse = enforceDiversity(recs, wanted - combined.length);
        combined = dedupeById([...combined, ...diverse]).slice(0, wanted);
      } catch {}
    }
  }

  return {
    tracks: combined.map(t => ({
      id: t.id, name: t.name, artists: t.artists, uri: t.uri, open_url: t.open_url,
    })),
  };
}

/* ---------- general (no festival) ---------- */
function enforceDiversitySimple(tracks, wanted) {
  return enforceDiversity(tracks, wanted);
}

async function recsGeneral({ plan, accessToken, wanted }) {
  const out = [];
  const seeds = { tracks: [], artists: [], genres: Array.isArray(plan.targetGenres) ? plan.targetGenres.slice(0,5) : (Array.isArray(plan.genres) ? plan.genres.slice(0,5) : []) };
  const candidates = Array.isArray(plan.candidates) ? plan.candidates : [];

  for (const c of candidates) {
    if (out.length >= wanted) break;
    const qParts = [];
    if (c?.track)  qParts.push(`track:"${String(c.track).replace(/"/g,"")}"`);
    if (c?.artist) qParts.push(`artist:"${String(c.artist).replace(/"/g,"")}"`);
    const q = qParts.join(" ") || String(c?.track || c?.artist || "");
    if (!q) continue;

    const u = new URL("https://api.spotify.com/v1/search");
    u.searchParams.set("q", q);
    u.searchParams.set("type", "track");
    u.searchParams.set("limit", "5");
    u.searchParams.set("market", "from_token");
    try {
      const data = await spotifyGET(accessToken, u.toString());
      const it = (data?.tracks?.items || [])[0];
      const m = mapTrack(it);
      if (m) {
        out.push(m);
        if (seeds.tracks.length < 5) seeds.tracks.push(m.id);
      }
    } catch {}
  }

  let diversified = enforceDiversitySimple(dedupeById(out), wanted);

  if (diversified.length < wanted) {
    const recU = new URL("https://api.spotify.com/v1/recommendations");
    recU.searchParams.set("limit", String(Math.min(100, wanted - diversified.length)));
    if (seeds.tracks.length) recU.searchParams.set("seed_tracks", seeds.tracks.slice(0,5).join(","));
    if (seeds.artists?.length) recU.searchParams.set("seed_artists", seeds.artists.slice(0,5).join(","));
    if (seeds.genres?.length) recU.searchParams.set("seed_genres", seeds.genres.slice(0,5).join(","));
    try {
      const data = await spotifyGET(accessToken, recU.toString());
      const extra = (data?.tracks || []).map(mapTrack).filter(Boolean);
      diversified = enforceDiversitySimple(dedupeById([...diversified, ...extra]), wanted);
    } catch {}
  }

  return diversified.slice(0, wanted).map(t => ({
    id: t.id, name: t.name, artists: t.artists, uri: t.uri, open_url: t.open_url,
  }));
}

/* ---------- endpoint ---------- */
export default async function handler(req) {
  try {
    const token = await getToken({ req, secret: process.env.NEXTAUTH_SECRET });
    if (!token?.accessToken) {
      return NextResponse.json({ error: "no-access-token" }, { status: 401 });
    }

    const body = await req.json().catch(() => ({}));
    const plan = body?.plan || {};
    const wanted = clamp(Number(plan.count || 50), 1, 200);

    let tracks = [];
    let used = "general";

    if (plan.isEvent) {
      // Festival primero (filtro fuerte y diversidad); fallback solo si <50%
      const rFest = await recsFromFestival({ plan, accessToken: token.accessToken, wanted });
      tracks = rFest.tracks || [];
      used = "festival";
      if (tracks.length < Math.ceil(wanted * 0.5)) {
        const rGen = await recsGeneral({ plan, accessToken: token.accessToken, wanted });
        tracks = dedupeById([...tracks, ...rGen]).slice(0, wanted);
        used = "festival+fallback";
      }
    } else {
      tracks = await recsGeneral({ plan, accessToken: token.accessToken, wanted });
    }

    // Garantiza exactamente 'wanted'
    tracks = tracks.slice(0, wanted);

    return NextResponse.json({ ok: true, used, got: tracks.length, tracks });
  } catch (e) {
    return NextResponse.json({ error: "server", message: String(e?.message || e) }, { status: 500 });
  }
}

export const POST = handler;
export const GET = handler;
