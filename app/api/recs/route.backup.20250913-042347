import { NextResponse } from "next/server";
import { getToken } from "next-auth/jwt";

// ---- helpers comunes ----
function dedupeById(list) {
  const seen = new Set();
  const out = [];
  for (const t of list) {
    if (!t?.id) continue;
    if (seen.has(t.id)) continue;
    seen.add(t.id);
    out.push(t);
  }
  return out;
}
function mapTrack(t) {
  return {
    id: t.id,
    name: t.name,
    artists: (t.artists || []).map(a => a.name),
    uri: t.uri,
    open_url: t.external_urls?.spotify || `https://open.spotify.com/track/${t.id}`,
  };
}
async function searchOneTrack({ track, artist }, token) {
  const qParts = [];
  if (track)  qParts.push(`track:"${String(track).replace(/"/g,'')}"`);
  if (artist) qParts.push(`artist:"${String(artist).replace(/"/g,'')}"`);
  const q = qParts.join(" ");
  const url = new URL("https://api.spotify.com/v1/search");
  url.searchParams.set("q", q || (track || artist || ""));
  url.searchParams.set("type", "track");
  url.searchParams.set("limit", "5");
  url.searchParams.set("market", "from_token");

  const r = await fetch(url, {
    headers: { Authorization: `Bearer ${token}` },
    cache: "no-store",
  });
  if (!r.ok) return null;
  const data = await r.json();
  const items = data?.tracks?.items || [];
  if (!items.length) return null;

  // Si nos dieron artista, intenta coincidencia exacta
  if (artist) {
    const exact = items.find(it =>
      (it.artists || []).some(a => a.name.toLowerCase() === String(artist).toLowerCase())
    );
    if (exact) return mapTrack(exact);
  }
  return mapTrack(items[0]);
}

async function fillWithRecommendations({ have, need, token, seeds, opts = {} }) {
  if (need <= 0) return [];
  const url = new URL("https://api.spotify.com/v1/recommendations");
  url.searchParams.set("limit", String(Math.min(need, 100)));

  const seed_tracks = (seeds.tracks || []).slice(0, 5);
  const seed_artists = (seeds.artists || []).slice(0, Math.max(0, 5 - seed_tracks.length));
  const seed_genres = (seeds.genres || []).slice(0, Math.max(0, 5 - seed_tracks.length - seed_artists.length));

  if (seed_tracks.length) url.searchParams.set("seed_tracks", seed_tracks.join(","));
  if (seed_artists.length) url.searchParams.set("seed_artists", seed_artists.join(","));
  if (seed_genres.length) url.searchParams.set("seed_genres", seed_genres.join(","));

  if (opts.target_energy != null) url.searchParams.set("target_energy", String(opts.target_energy));
  if (opts.min_tempo != null) url.searchParams.set("min_tempo", String(opts.min_tempo));
  if (opts.max_tempo != null) url.searchParams.set("max_tempo", String(opts.max_tempo));

  const r = await fetch(url, {
    headers: { Authorization: `Bearer ${token}` },
    cache: "no-store",
  });
  if (!r.ok) return [];
  const data = await r.json();
  const recs = (data?.tracks || []).map(mapTrack);

  const haveIds = new Set(have.map(t => t.id));
  return recs.filter(t => !haveIds.has(t.id));
}

async function fetchAudioFeatures(ids, token) {
  if (!ids.length) return {};
  const out = {};
  for (let i = 0; i < ids.length; i += 100) {
    const chunk = ids.slice(i, i + 100);
    const url = new URL("https://api.spotify.com/v1/audio-features");
    url.searchParams.set("ids", chunk.join(","));
    const r = await fetch(url, { headers: { Authorization: `Bearer ${token}` }, cache: "no-store" });
    if (!r.ok) continue;
    const data = await r.json();
    for (const f of data?.audio_features || []) {
      if (f?.id) out[f.id] = f;
    }
  }
  return out;
}

async function harvestFromPlaylists(queries, token, max = 200) {
  const collected = [];
  const seen = new Set();

  for (const q of queries) {
    // 1) busca playlists
    const url = new URL("https://api.spotify.com/v1/search");
    url.searchParams.set("q", q);
    url.searchParams.set("type", "playlist");
    url.searchParams.set("limit", "3");
    const r = await fetch(url, { headers: { Authorization: `Bearer ${token}` }, cache: "no-store" });
    if (!r.ok) continue;
    const data = await r.json();
    const pls = data?.playlists?.items || [];
    // 2) agarra tracks de cada playlist
    for (const p of pls) {
      const pid = p?.id;
      if (!pid) continue;
      const pr = await fetch(`https://api.spotify.com/v1/playlists/${pid}/tracks?limit=100`, {
        headers: { Authorization: `Bearer ${token}` },
        cache: "no-store",
      });
      if (!pr.ok) continue;
      const pdata = await pr.json();
      for (const it of pdata?.items || []) {
        const t = it?.track;
        if (!t?.id) continue;
        if (seen.has(t.id)) continue;
        seen.add(t.id);
        collected.push(mapTrack(t));
        if (collected.length >= max) break;
      }
      if (collected.length >= max) break;
    }
    if (collected.length >= max) break;
  }
  return collected;
}

export default async function handler(req) {
  try {
    // auth
    const token = await getToken({ req, secret: process.env.NEXTAUTH_SECRET });
    if (!token?.accessToken) {
      return NextResponse.json({ error: "no-access-token" }, { status: 401 });
    }
    // plan
    let plan = null;
    if (req.method === "GET") {
      const sp = new URL(req.url).searchParams;
      plan = JSON.parse(sp.get("plan") || "null");
    } else {
      const body = await req.json().catch(() => ({}));
      plan = body?.plan || null;
    }
    if (!plan) {
      return NextResponse.json({ error: "no-plan" }, { status: 400 });
    }

    const wanted = Math.max(1, Math.min(Number(plan.count || 50), 200));

    // PASO 1: probar candidatos (track + artist) que vengan del plan
    const found = [];
    const seeds = { tracks: [], artists: [], genres: (plan.targetGenres || []).slice(0,5) };

    if (Array.isArray(plan.candidates)) {
      for (const c of plan.candidates) {
        if (found.length >= wanted) break;
        const t = await searchOneTrack(
          { track: String(c?.track || "").slice(0, 120), artist: String(c?.artist || "").slice(0, 80) },
          token.accessToken
        );
        if (t) {
          found.push(t);
          if (seeds.tracks.length < 5) seeds.tracks.push(t.id);
        }
      }
    }

    // PASO 2 (CLÁSICA): si pide clásica, cosecha de playlists específicas
    if (plan?.domain?.classical && found.length < wanted) {
      const q = [
        "classical energetic",
        "baroque presto",
        "allegro vivace orchestra",
        "epic classical",
        "vivaldi presto",
        "workout classical"
      ];
      const plHarvest = await harvestFromPlaylists(q, token.accessToken, Math.min(200, wanted*2));
      const merged = dedupeById([...found, ...plHarvest]);
      // Si pide energía, filtra por audio features
      let finalList = merged;
      if (plan?.domain?.energyBoost) {
        const feats = await fetchAudioFeatures(finalList.map(t=>t.id), token.accessToken);
        finalList = finalList.filter(t => {
          const f = feats[t.id];
          return f && ((f.energy || 0) >= 0.55 || (f.tempo || 0) >= 110);
        });
      }
      // actualiza found con límite
      for (const t of finalList) {
        if (found.length >= wanted) break;
        if (!found.find(x=>x.id===t.id)) found.push(t);
      }
    }

    // PASO 3: si faltan, /recommendations con seeds y energía/tempo si procede
    if (found.length < wanted) {
      const opts = {};
      if (plan?.domain?.classical && plan?.domain?.energyBoost) {
        if (!seeds.genres?.length) seeds.genres = ["classical"]; // seed de género
        opts.target_energy = 0.6;
        opts.min_tempo = 110;
        opts.max_tempo = 190;
      }
      const extra = await fillWithRecommendations({
        have: found,
        need: wanted - found.length,
        token: token.accessToken,
        seeds,
        opts
      });
      for (const t of extra) {
        if (found.length >= wanted) break;
        if (!found.find(x=>x.id===t.id)) found.push(t);
      }
    }

    const tracks = dedupeById(found).slice(0, wanted);
    return NextResponse.json({ ok: true, got: tracks.length, tracks });
  } catch (e) {
    return NextResponse.json({ error: "server", message: String(e?.message || e) }, { status: 500 });
  }
}

export const GET = handler;
export const POST = handler;
