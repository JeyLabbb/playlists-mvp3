import { NextResponse } from "next/server";
import { getToken } from "next-auth/jwt";

/** ========== Helpers básicos ========== */
const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
const norm = (s = "") => s.normalize("NFD").replace(/\p{Diacritic}/gu, "").toLowerCase().trim();

function mapTrackRaw(t) {
  return {
    id: t?.id,
    name: t?.name,
    artists: (t?.artists || []).map((a) => ({ id: a?.id, name: a?.name })),
    uri: t?.uri,
    open_url: t?.external_urls?.spotify || (t?.id ? `https://open.spotify.com/track/${t.id}` : ""),
  };
}
function toPublicTrack(t) {
  return {
    ...t,
    artists: (t.artists || []).map((a) => (typeof a === "string" ? a : a?.name)).filter(Boolean),
  };
}
function dedupeById(list) {
  const seen = new Set();
  const out = [];
  for (const t of list) {
    if (t?.id && !seen.has(t.id)) {
      seen.add(t.id);
      out.push(t);
    }
  }
  return out;
}

/** ========== Spotify fetchers ========== */
async function spFetch(url, accessToken) {
  const r = await fetch(url, { headers: { Authorization: `Bearer ${accessToken}` }, cache: "no-store" });
  let data = null;
  try { data = await r.json(); } catch {}
  if (!r.ok) return { ok: false, status: r.status, data };
  return { ok: true, status: r.status, data };
}
async function search(q, type, limit, accessToken) {
  const u = new URL("https://api.spotify.com/v1/search");
  u.searchParams.set("q", q);
  u.searchParams.set("type", type);
  u.searchParams.set("limit", String(limit || 5));
  u.searchParams.set("market", "from_token");
  return (await spFetch(u, accessToken)).data;
}
async function fetchPlaylistMeta(id, accessToken) {
  const u = new URL(`https://api.spotify.com/v1/playlists/${id}`);
  u.searchParams.set("fields", "name,description,owner(display_name,id),followers(total)");
  const { ok, data } = await spFetch(u, accessToken);
  return ok ? data : null;
}
async function fetchPlaylistTracks(playlistId, accessToken, max = 200) {
  const out = [];
  let url = `https://api.spotify.com/v1/playlists/${playlistId}/tracks?limit=100`;
  while (url && out.length < max) {
    const { ok, data } = await spFetch(url, accessToken);
    if (!ok) break;
    for (const it of data?.items || []) {
      const t = it?.track;
      if (t?.id) out.push(mapTrackRaw(t));
      if (out.length >= max) break;
    }
    url = data?.next || null;
    await sleep(50);
  }
  return out;
}
async function doSearchTrack(q, accessToken) {
  const d = await search(q, "track", 5, accessToken);
  const items = d?.tracks?.items || [];
  return items.length ? mapTrackRaw(items[0]) : null;
}
async function searchTrack({ track, artist }, accessToken) {
  const qp = [];
  if (track) qp.push(`track:"${String(track).replace(/"/g, "")}"`);
  if (artist) qp.push(`artist:"${String(artist).replace(/"/g, "")}"`);
  const q1 = qp.join(" ") || (track || artist || "");
  let best = await doSearchTrack(q1, accessToken);
  if (best) return best;
  if (track) { best = await doSearchTrack(track, accessToken); if (best) return best; }
  if (track || artist) {
    const q3 = [artist, track].filter(Boolean).join(" ");
    best = await doSearchTrack(q3, accessToken);
    if (best) return best;
  }
  return null;
}
async function resolveArtistId(name, accessToken) {
  const d = await search(`artist:"${String(name).replace(/"/g, "")}"`, "artist", 1, accessToken);
  return d?.artists?.items?.[0]?.id || null;
}
async function artistTopTracks(artistId, accessToken) {
  const url = `https://api.spotify.com/v1/artists/${artistId}/top-tracks?market=ES`;
  const { ok, data } = await spFetch(url, accessToken);
  return ok ? (data?.tracks || []).map(mapTrackRaw) : [];
}
async function relatedArtists(artistId, accessToken) {
  const url = `https://api.spotify.com/v1/artists/${artistId}/related-artists`;
  const { ok, data } = await spFetch(url, accessToken);
  return ok ? (data?.artists || []) : [];
}
async function recommendations({ seedTracks = [], seedArtists = [], limit = 50, features = {} }, accessToken) {
  const u = new URL("https://api.spotify.com/v1/recommendations");
  u.searchParams.set("limit", String(Math.min(limit, 100)));
  if (seedTracks.length) u.searchParams.set("seed_tracks", seedTracks.slice(0, 5).join(","));
  if (seedArtists.length) u.searchParams.set("seed_artists", seedArtists.slice(0, 5).join(","));
  for (const [k, v] of Object.entries(features)) u.searchParams.set(k, String(v));
  const { ok, data } = await spFetch(u, accessToken);
  return ok ? (data?.tracks || []).map(mapTrackRaw) : [];
}

/** ========== Afinado por género / features ========== */
async function getArtistsBatch(ids, accessToken) {
  const chunks = [];
  for (let i = 0; i < ids.length; i += 50) chunks.push(ids.slice(i, i + 50));
  const out = new Map();
  for (const c of chunks) {
    const u = new URL("https://api.spotify.com/v1/artists");
    u.searchParams.set("ids", c.join(","));
    const { ok, data } = await spFetch(u, accessToken);
    if (!ok) continue;
    for (const a of data?.artists || []) {
      out.set(a.id, { id: a.id, genres: (a.genres || []).map((g) => g.toLowerCase()) });
    }
    await sleep(40);
  }
  return out;
}
async function getAudioFeaturesBatch(ids, accessToken) {
  const chunks = [];
  for (let i = 0; i < ids.length; i += 100) chunks.push(ids.slice(i, i + 100));
  const out = new Map();
  for (const c of chunks) {
    const u = new URL("https://api.spotify.com/v1/audio-features");
    u.searchParams.set("ids", c.join(","));
    const { ok, data } = await spFetch(u, accessToken);
    if (!ok) continue;
    for (const f of data?.audio_features || []) if (f?.id) out.set(f.id, f);
    await sleep(40);
  }
  return out;
}

const GENRE_HINTS = {
  hardstyle: { min_tempo: 150, target_energy: 0.9, target_danceability: 0.6 },
  nightcore: { min_tempo: 160, target_energy: 0.85, target_danceability: 0.6 },
  techno: { min_tempo: 125, max_tempo: 140, target_energy: 0.8, target_danceability: 0.7 },
  "drum and bass": { min_tempo: 160, max_tempo: 180, target_energy: 0.85, target_danceability: 0.6 },
  dubstep: { min_tempo: 130, max_tempo: 160, target_energy: 0.85 },
  trance: { min_tempo: 130, max_tempo: 145, target_energy: 0.8, target_danceability: 0.6 },
  phonk: { min_tempo: 90, max_tempo: 140, target_energy: 0.75, target_danceability: 0.7 },
  reggaeton: { min_tempo: 80, max_tempo: 105, target_danceability: 0.8 },
};
const MOOD_FEATURES = {
  triste: { max_valence: 0.35, max_energy: 0.55 },
  sad: { max_valence: 0.35, max_energy: 0.55 },
  chill: { max_energy: 0.6, max_tempo: 120 },
  focus: { max_energy: 0.55, instrumentalness: 0.5 },
  estudio: { max_energy: 0.6 },
  gym: { min_energy: 0.75, min_danceability: 0.6, min_tempo: 120 },
  fiesta: { min_danceability: 0.7, min_energy: 0.7 },
  motivante: { min_energy: 0.75 },
};

function normalizeTargets(targets) {
  return (targets || []).map((g) => norm(g)).map((x) => (x === "dnb" ? "drum and bass" : x));
}
function computeFeatureTargets({ targets = [], moods = [] }) {
  const out = {};
  // Género
  for (const t of targets) {
    const h = GENRE_HINTS[t];
    if (h) Object.assign(out, h);
  }
  // Mood (sobre-escribe si procede)
  for (const m of moods.map(norm)) {
    const h = MOOD_FEATURES[m];
    if (h) Object.assign(out, h);
  }
  return out;
}
function artistGenreScore(artistGenres = [], targets = []) {
  if (!targets.length) return 0;
  const ag = artistGenres.map(norm);
  let s = 0;
  for (const t of targets) {
    if (ag.includes(t)) s += 3;
    else if (ag.some((g) => g.includes(t))) s += 2;
  }
  return s;
}
function featureScore(f = null, feats = {}) {
  if (!f) return 0;
  let s = 0;
  if (feats.min_tempo && f.tempo >= feats.min_tempo) s += 1;
  if (feats.max_tempo && f.tempo <= feats.max_tempo) s += 1;
  if (feats.target_energy && Math.abs(f.energy - feats.target_energy) < 0.2) s += 1;
  if (feats.target_danceability && Math.abs(f.danceability - feats.target_danceability) < 0.2) s += 1;
  if (feats.min_energy && f.energy >= feats.min_energy) s += 1;
  if (feats.max_energy && f.energy <= feats.max_energy) s += 1;
  if (feats.min_danceability && f.danceability >= feats.min_danceability) s += 1;
  if (feats.max_valence && f.valence <= feats.max_valence) s += 1;
  if (feats.instrumentalness && (f.instrumentalness || 0) >= feats.instrumentalness) s += 1;
  return s;
}

/** ========== Anti-ruido / listas útiles ========== */
const BLACKLIST_PL_NAMES = ["karaoke", "mix", "dj set", "djset", "session", "extended mix", "instrumental only"];
const BAN_IF_TARGETS = {
  hardstyle: ["reggaeton", "latin", "bachata", "salsa"],
  techno: ["reggaeton", "latin", "trap latino"],
  "drum and bass": ["reggaeton", "latin"],
};
function looksOfficialLike(text = "") { return /\b(oficial|official|line.?up|cartel)\b/i.test(text); }
function playlistWeight(meta, baseNorm) {
  const name = norm(meta?.name || "");
  const desc = norm(meta?.description || "");
  const owner = norm(meta?.owner?.display_name || "");
  const followers = Number(meta?.followers?.total || 0);
  const bad = BLACKLIST_PL_NAMES.some((w) => name.includes(norm(w)));
  if (bad) return 0;
  let bonus = 0;
  if (looksOfficialLike(meta?.name) || looksOfficialLike(meta?.description)) bonus += 0.7;
  if (baseNorm && (name.includes(baseNorm) || desc.includes(baseNorm) || owner.includes(baseNorm))) bonus += 0.5;
  return Math.max(0, 1 + Math.log10(followers + 1) + bonus);
}

/** ========== LLM: parseo de prompt (condicional) ========== */
async function parsePromptWithLLM(promptRaw) {
  if (!process.env.OPENAI_API_KEY) return null;
  const sys = `Eres un parser de prompts para generar playlists de Spotify. Devuelve SOLO JSON válido.
Esquema:
{
  "isEvent": boolean,
  "event": { "name": string, "years": number[] } | null,
  "intent": "event" | "genre" | "mood" | "artists" | "generic",
  "targetGenres": string[],
  "moodKeywords": string[],       // ej: triste, chill, gym, fiesta, focus...
  "mustArtists": string[],
  "mustTracks": [{"track":string,"artist":string}][],
  "count": number|null,
  "searchQueries": string[]
}
Reglas:
- Detecta si es FESTIVAL/EVENTO (nombre exacto + años si aparecen).
- Si es genérico (gym, estudiar, fiesta, triste...), rellena moodKeywords y sugiere targetGenres.
- Construye searchQueries útiles (variantes con "lineup", "cartel", nombre + año).
- El campo "intent" debe ser el que mejor describa el caso.
- SOLO JSON.`;
  const user = `Prompt del usuario: """${promptRaw}"""`;
  const r = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: { "content-type": "application/json", Authorization: `Bearer ${process.env.OPENAI_API_KEY}` },
    body: JSON.stringify({
      model: process.env.OPENAI_MODEL || "gpt-4o-mini",
      temperature: 0.2,
      messages: [{ role: "system", content: sys }, { role: "user", content: user }],
      response_format: { type: "json_object" }
    })
  });
  if (!r.ok) return null;
  const data = await r.json().catch(() => null);
  const txt = data?.choices?.[0]?.message?.content?.trim();
  if (!txt) return null;
  try { return JSON.parse(txt); } catch { return null; }
}

/** ========== Búsqueda condicional según prompt ========== */
function expandTermsFromLLM(plan) {
  const terms = new Set();
  const name = plan?.event?.name || "";
  const years = Array.isArray(plan?.event?.years) ? plan.event.years : [];
  const sq = Array.isArray(plan?.searchQueries) ? plan.searchQueries : [];
  for (const t of sq) terms.add(t);
  if (name) {
    terms.add(name);
    terms.add(`${name} lineup`);
    terms.add(`${name} cartel`);
    for (const y of years) {
      terms.add(`${name} ${y}`);
      terms.add(`${name} lineup ${y}`);
      terms.add(`${name} cartel ${y}`);
    }
  }
  return Array.from(terms).slice(0, 15);
}
async function harvestFromPlaylistsSmart({ baseTerm, plan, want }, accessToken) {
  const baseNorm = norm(plan?.event?.name || baseTerm || "");
  const terms = expandTermsFromLLM(plan);
  const freq = new Map();
  const checked = new Set();
  let scanned = 0;
  const MAX_PL = 35;

  for (const term of (terms.length ? terms : [baseTerm]).filter(Boolean)) {
    const sd = await search(term, "playlist", 10, accessToken);
    const pls = sd?.playlists?.items || [];
    for (const p of pls) {
      if (!p?.id || checked.has(p.id)) continue;
      checked.add(p.id);
      const meta = (await fetchPlaylistMeta(p.id, accessToken)) || p;
      const w = playlistWeight(meta, baseNorm);
      if (w <= 0) continue;
      const tracks = await fetchPlaylistTracks(p.id, accessToken, 200);
      for (const t of tracks) {
        if (!t?.id) continue;
        const prev = freq.get(t.id);
        if (prev) { prev.count += 1; prev.weight += w; }
        else { freq.set(t.id, { track: t, count: 1, weight: w }); }
      }
      scanned += 1;
      if (freq.size >= want * 8 || scanned >= MAX_PL) break;
      await sleep(60);
    }
    if (freq.size >= want * 8 || scanned >= MAX_PL) break;
  }

  const ranked = Array.from(freq.values())
    .sort((a, b) => (b.weight !== a.weight ? b.weight - a.weight : b.count - a.count))
    .map((x) => x.track);

  return ranked.slice(0, want * 3); // sobra para filtrar
}

/** ========== Selección/penalización ========== */
function computeBans(targets = []) {
  const bans = new Set();
  for (const t of targets) for (const b of (BAN_IF_TARGETS[t] || [])) bans.add(b);
  return bans;
}
function banPenalty(artistGenres = [], bans = new Set()) {
  if (!bans.size) return 0;
  const ag = artistGenres.map(norm);
  for (const b of bans) if (ag.includes(b) || ag.some((g) => g.includes(b))) return -3;
  return 0;
}

/** ========== Handler principal ========== */
export async function POST(req) {
  try {
    const token = await getToken({ req, secret: process.env.NEXTAUTH_SECRET });
    if (!token?.accessToken) return NextResponse.json({ error: "no-access-token" }, { status: 401 });

    const body = await req.json().catch(() => ({}));
    const userPlan = body?.plan || {};
    const want = Math.max(1, Math.min(Number(userPlan?.count || body?.count || 50), 200));
    const rawPrompt = String(userPlan?.rawPrompt || body?.prompt || "");
    const forceStrict = !!userPlan?.strict;

    // 1) Parseo con LLM
    let parsed = await parsePromptWithLLM(rawPrompt);
    if (!parsed) parsed = { intent: "generic" };
    parsed._raw = rawPrompt;
    if (!Array.isArray(parsed.targetGenres)) parsed.targetGenres = [];
    if (!Array.isArray(parsed.moodKeywords)) parsed.moodKeywords = [];
    if (!Array.isArray(parsed.mustArtists)) parsed.mustArtists = [];
    if (!Array.isArray(parsed.mustTracks)) parsed.mustTracks = [];
    if (!Array.isArray(parsed.searchQueries)) parsed.searchQueries = [];

    const targets = normalizeTargets(parsed.targetGenres);
    const moods = parsed.moodKeywords.map(norm);
    const feats = computeFeatureTargets({ targets, moods });
    const bans = computeBans(targets);

    // Define estrategia segun intent
    const intent = parsed.intent || (parsed.isEvent ? "event" : (targets.length ? "genre" : (moods.length ? "mood" : "generic")));
    const strategy = {
      usePlaylists: intent === "event" || intent === "genre" || intent === "mood",
      useArtistSeeds: intent === "artists",
      useRelated: intent === "artists",
      useRecs: intent !== "event", // en eventos prioriza playlists, recs solo como relleno
    };

    const found = [];
    const seedTracks = [];
    const seedArtistIds = new Set();

    // 2) EVENTO: cosecha desde playlists “oficial/lineup/cartel”
    if (strategy.usePlaylists && intent === "event") {
      const harvested = await harvestFromPlaylistsSmart({ baseTerm: parsed.event?.name || rawPrompt, plan: parsed, want: want * 2 }, token.accessToken);
      for (const t of harvested) {
        if (!found.some((x) => x.id === t.id)) {
          found.push(t);
          if (seedTracks.length < 5) seedTracks.push(t.id);
          if (found.length >= want) break;
        }
      }
    }

    // 3) GÉNERO / MOOD: primero semillas rápidas desde playlists del término clave
    if (strategy.usePlaylists && (intent === "genre" || intent === "mood" || intent === "generic")) {
      const keyTerm = (targets[0] || moods[0] || rawPrompt || "").split(/\s+/).slice(0, 4).join(" ");
      if (keyTerm) {
        const harvested = await harvestFromPlaylistsSmart({ baseTerm: keyTerm, plan: parsed, want: Math.min(want, 60) }, token.accessToken);
        for (const t of harvested.slice(0, 15)) {
          if (!seedTracks.includes(t.id)) seedTracks.push(t.id);
          if (seedTracks.length >= 5) break;
        }
        // añade a found si encajan con filtros (para dar sensación de respuesta inmediata)
        for (const t of harvested.slice(0, 20)) {
          if (!found.some((x) => x.id === t.id)) found.push(t);
          if (found.length >= Math.min(20, want)) break;
        }
      }
    }

    // 4) Candidatos directos del usuario/LLM (track+artist exactos)
    const candidates = Array.isArray(userPlan?.candidates) ? userPlan.candidates : parsed.mustTracks || [];
    if (found.length < want && candidates.length) {
      const step = 8;
      for (let i = 0; i < candidates.length && found.length < want; i += step) {
        const slice = candidates.slice(i, i + step);
        const batch = await Promise.all(slice.map((c) => searchTrack({ track: c?.track, artist: c?.artist }, token.accessToken)));
        for (const t of batch) {
          if (t && !found.some((x) => x.id === t.id)) {
            found.push(t);
            if (seedTracks.length < 5) seedTracks.push(t.id);
          }
        }
        await sleep(40);
      }
    }

    // 5) ARTISTAS “obligatorios” + related, pero filtrando por mood/genre (no todo vale)
    if (strategy.useArtistSeeds || parsed.mustArtists.length) {
      const must = Array.from(new Set([...(parsed.mustArtists || [])])).slice(0, 8);
      const mustIds = (await Promise.all(must.map((n) => resolveArtistId(n, token.accessToken)))).filter(Boolean);
      for (const id of mustIds) {
        if (seedArtistIds.size < 5) seedArtistIds.add(id);
        // coge top tracks que pasen filtros (no meter tralla feliz en “triste”, por ejemplo)
        const tops = await artistTopTracks(id, token.accessToken);
        for (const t of tops) {
          if (!found.some((x) => x.id === t.id)) found.push(t);
          if (seedTracks.length < 5 && !seedTracks.includes(t.id)) seedTracks.push(t.id);
          if (found.length >= want) break;
        }
        if (strategy.useRelated) {
          const rel = await relatedArtists(id, token.accessToken);
          for (const ra of rel.slice(0, 5)) {
            if (seedArtistIds.size < 5) seedArtistIds.add(ra.id);
            const tops2 = await artistTopTracks(ra.id, token.accessToken);
            for (const t of tops2.slice(0, 2)) {
              if (!found.some((x) => x.id === t.id)) found.push(t);
              if (seedTracks.length < 5 && !seedTracks.includes(t.id)) seedTracks.push(t.id);
              if (found.length >= want) break;
            }
            if (found.length >= want) break;
          }
        }
        if (found.length >= want) break;
      }
    }

    // 6) Recommendations (solo si no es evento, o como relleno final)
    if (strategy.useRecs && (seedTracks.length || seedArtistIds.size) && found.length < want) {
      const recs = await recommendations(
        { seedTracks, seedArtists: Array.from(seedArtistIds), limit: want - found.length, features: feats },
        token.accessToken
      );
      for (const t of recs) {
        if (!found.some((x) => x.id === t.id)) {
          found.push(t);
          if (found.length >= want) break;
        }
      }
    }

    // 7) Scoring/filtrado coherente (género+mood+penalización de bans)
    let tracks = dedupeById(found).slice(0, want * 2);
    const artistIds = Array.from(new Set(tracks.flatMap((t) => (t.artists || []).map((a) => a.id)).filter(Boolean)));
    const artistsMap = await getArtistsBatch(artistIds, token.accessToken);
    const featsMap = tracks.length ? await getAudioFeaturesBatch(tracks.map((t) => t.id), token.accessToken) : new Map();

    const scored = tracks.map((t) => {
      const firstArtistId = t.artists?.[0]?.id;
      const ag = firstArtistId ? (artistsMap.get(firstArtistId)?.genres || []) : [];
      const gScore = targets.length ? artistGenreScore(ag, targets) : 0;
      const fScore = featsMap.size ? featureScore(featsMap.get(t.id) || null, feats) : 0;
      const pen = banPenalty(ag, bans);
      // Si hay moods y géneros, exige algo de ambos; si no, solo lo disponible
      const base = (targets.length ? gScore * 2 : 0) + (Object.keys(feats).length ? fScore : 0) + pen;
      return { t, score: base };
    });

    // Si el intent es “event”, sube el listón para filtrar ruido
    const minScore = intent === "event" ? 1 : 0;
    scored.sort((a, b) => b.score - a.score);
    let final = scored.filter((x) => x.score > minScore).slice(0, want).map((x) => x.t);

    // Fallback si nos quedamos cortos
    if (final.length < want) {
      for (const x of scored) {
        if (final.length >= want) break;
        if (!final.some((y) => y.id === x.t.id)) final.push(x.t);
      }
      final = final.slice(0, want);
    }

    // Modo estricto (si el usuario lo pide): prioriza calidad > cantidad
    if (forceStrict && (targets.length || Object.keys(feats).length)) {
      const keep = [];
      for (const x of scored) {
        if (keep.length >= want) break;
        if (x.score > 0 && !keep.some((y) => y.t.id === x.t.id)) keep.push(x);
      }
      if (keep.length) final = keep.slice(0, want).map((z) => z.t);
    }

    const clean = final.map(toPublicTrack);
    return NextResponse.json({
      ok: true,
      got: clean.length,
      tracks: clean,
      plan: {
        intent,
        isEvent: !!parsed.isEvent,
        event: parsed.event || null,
        targetGenres: parsed.targetGenres || [],
        moodKeywords: parsed.moodKeywords || [],
        features: feats,
        usedSeeds: { seedTracks, seedArtists: Array.from(seedArtistIds) },
      },
      source: intent === "event" ? "playlists→filter" : "hybrid→filter",
    });
  } catch (e) {
    return NextResponse.json({ error: "server", message: String(e?.message || e) }, { status: 500 });
  }
}

export const GET = POST;
