import { NextResponse } from "next/server";
import { getToken } from "next-auth/jwt";

const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
const norm = (s = "") =>
  s
    .normalize("NFD")
    .replace(/\p{Diacritic}/gu, "")
    .toLowerCase()
    .trim();

function mapTrackRaw(t) {
  return {
    id: t?.id,
    name: t?.name,
    artists: (t?.artists || []).map((a) => ({ id: a?.id, name: a?.name })),
    uri: t?.uri,
    open_url: t?.external_urls?.spotify || (t?.id ? `https://open.spotify.com/track/${t.id}` : ""),
  };
}

function toPublicTrack(t) {
  return {
    ...t,
    artists: (t.artists || [])
      .map((a) => (typeof a === "string" ? a : a?.name))
      .filter(Boolean),
  };
}

function dedupeById(list) {
  const seen = new Set();
  const out = [];
  for (const t of list) {
    if (t?.id && !seen.has(t.id)) {
      seen.add(t.id);
      out.push(t);
    }
  }
  return out;
}

/* ================== Spotify helpers ================== */
async function spFetch(url, accessToken) {
  const r = await fetch(url, {
    headers: { Authorization: `Bearer ${accessToken}` },
    cache: "no-store",
  });
  if (!r.ok) return { ok: false, status: r.status, data: null };
  const data = await r.json().catch(() => null);
  return { ok: true, status: r.status, data };
}

async function search(q, type, limit, accessToken) {
  const u = new URL("https://api.spotify.com/v1/search");
  u.searchParams.set("q", q);
  u.searchParams.set("type", type);
  u.searchParams.set("limit", String(limit || 5));
  u.searchParams.set("market", "from_token");
  const { ok, data } = await spFetch(u, accessToken);
  return ok ? data : null;
}

async function fetchPlaylistMeta(id, accessToken) {
  const u = new URL(`https://api.spotify.com/v1/playlists/${id}`);
  u.searchParams.set("fields", "name,description,owner(display_name,id),followers(total)");
  const { ok, data } = await spFetch(u, accessToken);
  return ok ? data : null;
}

async function fetchPlaylistTracks(playlistId, accessToken, max = 200) {
  const out = [];
  let url = `https://api.spotify.com/v1/playlists/${playlistId}/tracks?limit=100`;
  while (url && out.length < max) {
    const { ok, data } = await spFetch(url, accessToken);
    if (!ok) break;
    for (const it of data?.items || []) {
      const t = it?.track;
      if (t?.id) out.push(mapTrackRaw(t));
      if (out.length >= max) break;
    }
    url = data?.next || null;
    await sleep(60);
  }
  return out;
}

async function doSearchTrack(q, accessToken) {
  const d = await search(q, "track", 5, accessToken);
  const items = d?.tracks?.items || [];
  if (!items.length) return null;
  return mapTrackRaw(items[0]);
}

async function searchTrack({ track, artist }, accessToken) {
  const qp = [];
  if (track) qp.push(`track:"${String(track).replace(/"/g, "")}"`);
  if (artist) qp.push(`artist:"${String(artist).replace(/"/g, "")}"`);
  const q1 = qp.join(" ") || (track || artist || "");
  let best = await doSearchTrack(q1, accessToken);
  if (best) return best;
  if (track) {
    best = await doSearchTrack(track, accessToken);
    if (best) return best;
  }
  if (track || artist) {
    const q3 = [artist, track].filter(Boolean).join(" ");
    best = await doSearchTrack(q3, accessToken);
    if (best) return best;
  }
  return null;
}

async function resolveArtistId(name, accessToken) {
  const d = await search(`artist:"${String(name).replace(/"/g, "")}"`, "artist", 1, accessToken);
  const it = d?.artists?.items?.[0];
  return it?.id || null;
}

async function artistTopTracks(artistId, accessToken) {
  const url = `https://api.spotify.com/v1/artists/${artistId}/top-tracks?market=ES`;
  const { ok, data } = await spFetch(url, accessToken);
  return ok ? (data?.tracks || []).map(mapTrackRaw) : [];
}

async function recommendations({ seedTracks = [], seedArtists = [], limit = 50, features = {} }, accessToken) {
  const u = new URL("https://api.spotify.com/v1/recommendations");
  u.searchParams.set("limit", String(Math.min(limit, 100)));
  if (seedTracks.length) u.searchParams.set("seed_tracks", seedTracks.slice(0, 5).join(","));
  if (seedArtists.length) u.searchParams.set("seed_artists", seedArtists.slice(0, 5).join(","));
  for (const [k, v] of Object.entries(features)) u.searchParams.set(k, String(v));
  const { ok, data } = await spFetch(u, accessToken);
  return ok ? (data?.tracks || []).map(mapTrackRaw) : [];
}

/* ================== Afinado por género/audio-features ================== */
async function getArtistsBatch(ids, accessToken) {
  const chunks = [];
  for (let i = 0; i < ids.length; i += 50) chunks.push(ids.slice(i, i + 50));
  const out = new Map();
  for (const c of chunks) {
    const u = new URL("https://api.spotify.com/v1/artists");
    u.searchParams.set("ids", c.join(","));
    const { ok, data } = await spFetch(u, accessToken);
    if (!ok) continue;
    for (const a of data?.artists || []) {
      out.set(a.id, { id: a.id, genres: (a.genres || []).map((g) => g.toLowerCase()) });
    }
    await sleep(40);
  }
  return out;
}

async function getAudioFeaturesBatch(ids, accessToken) {
  const chunks = [];
  for (let i = 0; i < ids.length; i += 100) chunks.push(ids.slice(i, i + 100));
  const out = new Map();
  for (const c of chunks) {
    const u = new URL("https://api.spotify.com/v1/audio-features");
    u.searchParams.set("ids", c.join(","));
    const { ok, data } = await spFetch(u, accessToken);
    if (!ok) continue;
    for (const f of data?.audio_features || []) {
      if (f?.id) out.set(f.id, f);
    }
    await sleep(40);
  }
  return out;
}

const GENRE_HINTS = {
  hardstyle: { min_tempo: 150, target_energy: 0.9, target_danceability: 0.6 },
  nightcore: { min_tempo: 160, target_energy: 0.85, target_danceability: 0.6 },
  phonk: { min_tempo: 90, max_tempo: 140, target_energy: 0.75, target_danceability: 0.7 },
  techno: { min_tempo: 125, max_tempo: 140, target_energy: 0.8, target_danceability: 0.7 },
  "drum and bass": { min_tempo: 160, max_tempo: 180, target_energy: 0.85, target_danceability: 0.6 },
  dubstep: { min_tempo: 130, max_tempo: 160, target_energy: 0.85 },
  trance: { min_tempo: 130, max_tempo: 145, target_energy: 0.8, target_danceability: 0.6 },
  reggaeton: { min_tempo: 80, max_tempo: 105, target_danceability: 0.8 },
};

function normalizeTargets(targets) {
  return (targets || [])
    .map((g) => norm(g))
    .map((x) => (x === "dnb" ? "drum and bass" : x));
}

function genreHintsForSeeds(targets) {
  for (const t of targets) if (GENRE_HINTS[t]) return GENRE_HINTS[t];
  return null;
}

function artistGenreScore(artistGenres = [], targets = []) {
  if (!targets.length) return 0;
  const ag = artistGenres.map(norm);
  let s = 0;
  for (const t of targets) {
    if (ag.includes(t)) s += 3;
    else if (ag.some((g) => g.includes(t))) s += 2;
  }
  return s;
}

function featureScore(f = null, targets = []) {
  if (!f || !targets.length) return 0;
  const h = genreHintsForSeeds(targets);
  if (!h) return 0;
  let s = 0;
  if (h.min_tempo && f.tempo >= h.min_tempo) s += 1;
  if (h.max_tempo && f.tempo <= h.max_tempo) s += 1;
  if (h.target_energy && Math.abs(f.energy - h.target_energy) < 0.2) s += 1;
  if (h.target_danceability && Math.abs(f.danceability - h.target_danceability) < 0.2) s += 1;
  return s;
}

/* ================== Harvester robusto para festivales ================== */
const BLACKLIST_PL_NAMES = [
  "karaoke",
  "mix",
  "dj set",
  "djset",
  "session",
  "remix only",
  "extended mix",
  "instrumental",
  "nightcore (si no procede)",
];

function looksOfficialLike(text = "") {
  return /\b(oficial|official|line.?up|cartel)\b/i.test(text);
}

function expandEventTerms(rawPrompt = "") {
  const p = rawPrompt.trim();
  const base = norm(p.replace(/\b20\d{2}\b/g, "").replace(/\b(festival|cartel|line\s?-?\s?up|lineup)\b/gi, "").trim());
  const years = Array.from(new Set(p.match(/\b20\d{2}\b/g) || []));
  const set = new Set();
  if (p) set.add(p);
  if (base) {
    set.add(base);
    set.add(`${base} lineup`);
    set.add(`${base} cartel`);
  }
  for (const y of years) {
    if (base) {
      set.add(`${base} ${y}`);
      set.add(`${base} lineup ${y}`);
      set.add(`${base} cartel ${y}`);
    } else {
      set.add(`${p} ${y}`);
    }
  }
  // variantes sin tildes
  for (const x of Array.from(set)) set.add(norm(x));
  return Array.from(set).slice(0, 12);
}

function playlistWeight(meta, baseNorm) {
  const name = norm(meta?.name || "");
  const desc = norm(meta?.description || "");
  const owner = norm(meta?.owner?.display_name || "");
  const followers = Number(meta?.followers?.total || 0);

  // filtros rápidos por nombre "sospechoso"
  const bad = BLACKLIST_PL_NAMES.some((w) => name.includes(norm(w)));
  if (bad) return 0; // ignora listas ruidosas

  let bonus = 0;
  if (looksOfficialLike(meta?.name) || looksOfficialLike(meta?.description)) bonus += 0.7;
  if (baseNorm && (name.includes(baseNorm) || desc.includes(baseNorm) || owner.includes(baseNorm))) bonus += 0.5;

  // peso por seguidores (suavizado)
  return Math.max(0, 1 + Math.log10(followers + 1) + bonus);
}

async function harvestFromPlaylistsSmart({ rawPrompt, want }, accessToken) {
  const terms = expandEventTerms(rawPrompt);
  const baseNorm = norm(rawPrompt.replace(/\b20\d{2}\b/g, ""));
  const freq = new Map(); // id -> {track, count, score}
  const checked = new Set();
  let scanned = 0;

  // límite dinámico de playlists: más si no encontramos frecuencia
  const MAX_PL = 30;

  for (const term of terms) {
    const sd = await search(term, "playlist", 10, accessToken);
    const pls = sd?.playlists?.items || [];
    for (const p of pls) {
      if (!p?.id || checked.has(p.id)) continue;
      checked.add(p.id);

      const meta = (await fetchPlaylistMeta(p.id, accessToken)) || p;
      const w = playlistWeight(meta, baseNorm);
      if (w <= 0) continue; // ignora

      const tracks = await fetchPlaylistTracks(p.id, accessToken, 200);
      for (const t of tracks) {
        if (!t?.id) continue;
        const prev = freq.get(t.id);
        if (prev) {
          prev.count += 1;
          prev.score += w;
        } else {
          freq.set(t.id, { track: t, count: 1, score: w });
        }
      }
      scanned += 1;
      if (freq.size >= want * 8 || scanned >= MAX_PL) break;
      await sleep(80);
    }
    if (freq.size >= want * 8 || scanned >= MAX_PL) break;
  }

  // ranking por score ponderado y recuento
  const ranked = Array.from(freq.values())
    .sort((a, b) => {
      if (b.score !== a.score) return b.score - a.score;
      return b.count - a.count;
    })
    .map((x) => x.track);

  return ranked.slice(0, want * 2); // sobredimensiona para afinar
}

/* ================== Handler principal ================== */
export async function POST(req) {
  try {
    const token = await getToken({ req, secret: process.env.NEXTAUTH_SECRET });
    if (!token?.accessToken) return NextResponse.json({ error: "no-access-token" }, { status: 401 });

    const body = await req.json().catch(() => ({}));
    const plan = body?.plan || {};
    const want = Math.max(1, Math.min(Number(plan?.count || body?.count || 50), 200));
    const rawPrompt = String(plan?.rawPrompt || "");
    const candidates = Array.isArray(plan?.candidates) ? plan.candidates : [];
    const targets = normalizeTargets(plan?.targetGenres || []);
    const pLow = rawPrompt.toLowerCase();

    const looksEvent =
      !!plan?.isEvent ||
      /(festival|cartel|line[\s-]?up|lineup|primavera|mad\s?cool|riverland|boombastic|arenal|sonar|fib|o son do camiño|cruilla|groove)/i.test(
        pLow
      );

    const found = [];
    const seedTracks = [];
    const seedArtistIds = new Set();

    // 0) Evento: harvester ponderado multi-playlist
    if (looksEvent) {
      const harvested = await harvestFromPlaylistsSmart({ rawPrompt, want: want * 2 }, token.accessToken);
      // umbral de consenso: si hay suficiente materia, exige count>=2 (aprox. por score)
      const byId = new Map();
      for (const t of harvested) byId.set(t.id, t);

      // Construye frecuencias mínimas a partir del top
      const topSlice = harvested.slice(0, Math.min(harvested.length, want * 2));
      // No tenemos el "count" aquí, pero el ranking ya arrastra la ponderación; cogemos los primeros
      for (const t of topSlice) {
        if (!found.some((x) => x.id === t.id)) {
          found.push(t);
          if (seedTracks.length < 5) seedTracks.push(t.id);
          if (found.length >= Math.min(want, topSlice.length)) break;
        }
      }
    }

    // 1) Candidatos IA (match track+artist)
    if (found.length < want && candidates.length) {
      const step = 8;
      for (let i = 0; i < candidates.length && found.length < want; i += step) {
        const slice = candidates.slice(i, i + step);
        const batch = await Promise.all(
          slice.map((c) => searchTrack({ track: c?.track, artist: c?.artist }, token.accessToken))
        );
        for (const t of batch) {
          if (t && !found.some((x) => x.id === t.id)) {
            found.push(t);
            if (seedTracks.length < 5) seedTracks.push(t.id);
          }
        }
        await sleep(50);
      }
    }

    // 2) Top-tracks por artista (si quedaron artistas conocidos)
    if (found.length < want && candidates.length) {
      const artistNames = Array.from(new Set(candidates.map((c) => String(c?.artist || "").trim()).filter(Boolean))).slice(
        0,
        10
      );
      const ids = await Promise.all(artistNames.map((n) => resolveArtistId(n, token.accessToken)));
      for (const id of ids.filter(Boolean)) {
        if (seedArtistIds.size < 5) seedArtistIds.add(id);
        if (found.length >= want) break;
        const tops = await artistTopTracks(id, token.accessToken);
        for (const t of tops) {
          if (!found.some((x) => x.id === t.id)) {
            found.push(t);
            if (seedTracks.length < 5) seedTracks.push(t.id);
            if (found.length >= want) break;
          }
        }
      }
    }

    // 3) Recs finales con hints por género/tempo/energy si procede
    if (found.length < want && (seedTracks.length || seedArtistIds.size)) {
      const hints = genreHintsForSeeds(targets) || {};
      const recs = await recommendations(
        {
          seedTracks,
          seedArtists: Array.from(seedArtistIds),
          limit: want - found.length,
          features: hints,
        },
        token.accessToken
      );
      for (const t of recs) {
        if (!found.some((x) => x.id === t.id)) {
          found.push(t);
          if (found.length >= want) break;
        }
      }
    }

    // 4) Afinado por género + audio-features
    let tracks = dedupeById(found);
    const artistIds = Array.from(
      new Set(tracks.flatMap((t) => (t.artists || []).map((a) => a.id)).filter(Boolean))
    );
    const artistsMap = await getArtistsBatch(artistIds, token.accessToken);
    let featsMap = new Map();
    if (targets.length) {
      const trackIds = tracks.map((t) => t.id);
      featsMap = await getAudioFeaturesBatch(trackIds, token.accessToken);
    }

    const scored = tracks.map((t) => {
      const firstArtistId = t.artists?.[0]?.id;
      const ag = firstArtistId ? artistsMap.get(firstArtistId)?.genres || [] : [];
      const gScore = artistGenreScore(ag, targets);
      const fScore = featsMap.size ? featureScore(featsMap.get(t.id) || null, targets) : 0;
      return { t, score: gScore * 2 + fScore };
    });

    scored.sort((a, b) => b.score - a.score);
    const filtered = targets.length ? scored.filter((x) => x.score > 0) : scored;

    let final = filtered.slice(0, want).map((x) => x.t);
    if (final.length < want) {
      for (const x of scored) {
        if (final.length >= want) break;
        if (!final.some((y) => y.id === x.t.id)) final.push(x.t);
      }
      final = final.slice(0, want);
    }

    const clean = final.map(toPublicTrack);

    return NextResponse.json({
      ok: true,
      got: clean.length,
      tracks: clean,
      source: looksEvent ? "harvest-weighted" : "ai-first",
      targets,
    });
  } catch (e) {
    return NextResponse.json({ error: "server", message: String(e?.message || e) }, { status: 500 });
  }
}

export const GET = POST;
