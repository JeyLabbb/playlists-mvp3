import { NextResponse } from "next/server";
import { getToken } from "next-auth/jwt";

/** ===== Utils ===== */
const sleep = (ms) => new Promise((r) => setTimeout(r, ms));
const norm = (s = "") => s.normalize("NFD").replace(/\p{Diacritic}/gu, "").toLowerCase().trim();
const onlyWords = (s = "") => (s.toLowerCase().match(/[a-záéíóúüñ0-9]+/gi) || []);
const STOP = new Set(["playlist","para","prepararme","del","de","la","el","los","las","con","por","para","una","un","the","and","en"]);

/** ===== Mapeos ===== */
function mapTrackRaw(t) {
  return {
    id: t?.id,
    name: t?.name,
    artists: (t?.artists || []).map(a => ({ id: a?.id, name: a?.name })),
    uri: t?.uri,
    open_url: t?.external_urls?.spotify || (t?.id ? `https://open.spotify.com/track/${t.id}` : ""),
  };
}
function toPublicTrack(t) {
  return {
    ...t,
    artists: (t.artists || []).map(a => (typeof a === "string" ? a : a?.name)).filter(Boolean),
  };
}
function dedupeById(list) {
  const seen = new Set(); const out = [];
  for (const t of list) { if (t?.id && !seen.has(t.id)) { seen.add(t.id); out.push(t); } }
  return out;
}

/** ===== Spotify fetch ===== */
async function spFetch(url, accessToken) {
  const r = await fetch(url, { headers: { Authorization: `Bearer ${accessToken}` }, cache: "no-store" });
  let data = null; try { data = await r.json(); } catch {}
  if (!r.ok) return { ok:false, status:r.status, data };
  return { ok:true, status:r.status, data };
}
async function search(q, type, limit, accessToken) {
  const u = new URL("https://api.spotify.com/v1/search");
  u.searchParams.set("q", q);
  u.searchParams.set("type", type);
  u.searchParams.set("limit", String(limit || 5));
  u.searchParams.set("market","from_token");
  return (await spFetch(u, accessToken)).data;
}
async function fetchPlaylistMeta(id, accessToken) {
  const u = new URL(`https://api.spotify.com/v1/playlists/${id}`);
  u.searchParams.set("fields","name,description,owner(display_name,id),followers(total)");
  const { ok, data } = await spFetch(u, accessToken);
  return ok ? data : null;
}
async function fetchPlaylistTracks(playlistId, accessToken, max = 200) {
  const out = []; let url = `https://api.spotify.com/v1/playlists/${playlistId}/tracks?limit=100`;
  while (url && out.length < max) {
    const { ok, data } = await spFetch(url, accessToken);
    if (!ok) break;
    for (const it of data?.items || []) {
      const t = it?.track; if (t?.id) out.push(mapTrackRaw(t));
      if (out.length >= max) break;
    }
    url = data?.next || null; await sleep(50);
  }
  return out;
}
async function doSearchTrack(q, accessToken) {
  const d = await search(q, "track", 5, accessToken);
  const items = d?.tracks?.items || []; return items.length ? mapTrackRaw(items[0]) : null;
}
async function searchTrack({ track, artist }, accessToken) {
  const qp=[]; if(track) qp.push(`track:"${String(track).replace(/"/g,"")}"`);
  if(artist) qp.push(`artist:"${String(artist).replace(/"/g,"")}"`);
  const q1 = qp.join(" ") || (track || artist || "");
  let best = await doSearchTrack(q1, accessToken); if (best) return best;
  if (track) { best = await doSearchTrack(track, accessToken); if (best) return best; }
  if (track || artist) { const q3 = [artist,track].filter(Boolean).join(" "); best = await doSearchTrack(q3, accessToken); if (best) return best; }
  return null;
}
async function resolveArtistId(name, accessToken) {
  const d = await search(`artist:"${String(name).replace(/"/g,"")}"`, "artist", 1, accessToken);
  return d?.artists?.items?.[0]?.id || null;
}
async function artistTopTracks(artistId, accessToken) {
  const url = `https://api.spotify.com/v1/artists/${artistId}/top-tracks?market=ES`;
  const { ok, data } = await spFetch(url, accessToken);
  return ok ? (data?.tracks || []).map(mapTrackRaw) : [];
}
async function relatedArtists(artistId, accessToken) {
  const url = `https://api.spotify.com/v1/artists/${artistId}/related-artists`;
  const { ok, data } = await spFetch(url, accessToken);
  return ok ? (data?.artists || []) : [];
}
async function recommendations({ seedTracks=[], seedArtists=[], limit=50, features={} }, accessToken) {
  const u = new URL("https://api.spotify.com/v1/recommendations");
  u.searchParams.set("limit", String(Math.min(limit,100)));
  if (seedTracks.length) u.searchParams.set("seed_tracks", seedTracks.slice(0,5).join(","));
  if (seedArtists.length) u.searchParams.set("seed_artists", seedArtists.slice(0,5).join(","));
  for (const [k,v] of Object.entries(features)) u.searchParams.set(k, String(v));
  const { ok, data } = await spFetch(u, accessToken);
  return ok ? (data?.tracks || []).map(mapTrackRaw) : [];
}

/** ===== Genres/Moods → features ===== */
const GENRE_HINTS = {
  hardstyle:{ min_tempo:150, target_energy:0.9, target_danceability:0.6 },
  nightcore:{ min_tempo:160, target_energy:0.85, target_danceability:0.6 },
  techno:{ min_tempo:125, max_tempo:140, target_energy:0.8, target_danceability:0.7 },
  "drum and bass":{ min_tempo:160, max_tempo:180, target_energy:0.85, target_danceability:0.6 },
  dubstep:{ min_tempo:130, max_tempo:160, target_energy:0.85 },
  trance:{ min_tempo:130, max_tempo:145, target_energy:0.8, target_danceability:0.6 },
  phonk:{ min_tempo:90, max_tempo:140, target_energy:0.75, target_danceability:0.7 },
  reggaeton:{ min_tempo:80, max_tempo:105, target_danceability:0.8 },
};
const MOOD_FEATURES = {
  triste:{ max_valence:0.35, max_energy:0.55 },
  sad:{ max_valence:0.35, max_energy:0.55 },
  chill:{ max_energy:0.6, max_tempo:120 },
  focus:{ max_energy:0.55, instrumentalness:0.5 },
  estudio:{ max_energy:0.6 },
  gym:{ min_energy:0.75, min_danceability:0.6, min_tempo:120 },
  fiesta:{ min_danceability:0.7, min_energy:0.7 },
  motivante:{ min_energy:0.75 },
};
function normalizeTargets(targets){ return (targets||[]).map(g=>norm(g)).map(x=>x==="dnb"?"drum and bass":x); }
function computeFeatureTargets({ targets=[], moods=[] }) {
  const out={};
  for (const t of targets) { const h=GENRE_HINTS[t]; if (h) Object.assign(out,h); }
  for (const m of moods.map(norm)) { const h=MOOD_FEATURES[m]; if (h) Object.assign(out,h); }
  return out;
}
function artistGenreScore(artistGenres=[], targets=[]){
  if(!targets.length) return 0;
  const ag = artistGenres.map(norm); let s=0;
  for(const t of targets){ if(ag.includes(t)) s+=3; else if(ag.some(g=>g.includes(t))) s+=2; }
  return s;
}
function featureScore(f=null, feats={}){
  if(!f) return 0; let s=0;
  if(feats.min_tempo && f.tempo>=feats.min_tempo) s+=1;
  if(feats.max_tempo && f.tempo<=feats.max_tempo) s+=1;
  if(feats.target_energy && Math.abs(f.energy-feats.target_energy)<0.2) s+=1;
  if(feats.target_danceability && Math.abs(f.danceability-feats.target_danceability)<0.2) s+=1;
  if(feats.min_energy && f.energy>=feats.min_energy) s+=1;
  if(feats.max_energy && f.energy<=feats.max_energy) s+=1;
  if(feats.min_danceability && f.danceability>=feats.min_danceability) s+=1;
  if(feats.max_valence && f.valence<=feats.max_valence) s+=1;
  if(feats.instrumentalness && (f.instrumentalness||0)>=feats.instrumentalness) s+=1;
  return s;
}

/** ===== Anti-ruido ===== */
const BLACKLIST_PL_NAMES = ["karaoke","mix","dj set","djset","session","extended mix","instrumental only"];
const BAN_IF_TARGETS = {
  hardstyle:["reggaeton","latin","bachata","salsa"],
  techno:["reggaeton","latin","trap latino"],
  "drum and bass":["reggaeton","latin"],
};
function looksOfficialLike(text=""){ return /\b(oficial|official|line.?up|cartel)\b/i.test(text); }

/** ► NUEVO: tokens del evento deben aparecer en name/desc/owner */
function metaContainsAllTokens(meta, tokens=[]) {
  if (!tokens.length) return true;
  const name = norm(meta?.name||"");
  const desc = norm(meta?.description||"");
  const owner = norm(meta?.owner?.display_name||"");
  return tokens.every(t => name.includes(t) || desc.includes(t) || owner.includes(t));
}
function playlistWeight(meta, baseNorm, requiredTokens=[]) {
  const name = norm(meta?.name||"");
  const desc = norm(meta?.description||"");
  const owner = norm(meta?.owner?.display_name||"");
  const followers = Number(meta?.followers?.total||0);
  const bad = BLACKLIST_PL_NAMES.some(w => name.includes(norm(w)));
  if (bad) return 0;
  // ► si es evento y faltan tokens clave, descartar
  if (requiredTokens.length && !metaContainsAllTokens(meta, requiredTokens)) return 0;

  let bonus = 0;
  if (looksOfficialLike(meta?.name) || looksOfficialLike(meta?.description)) bonus += 0.7;
  if (baseNorm && (name.includes(baseNorm) || desc.includes(baseNorm) || owner.includes(baseNorm))) bonus += 0.5;
  return Math.max(0, 1 + Math.log10(followers + 1) + bonus);
}

/** ===== LLM parser (opcional) ===== */
async function parsePromptWithLLM(promptRaw) {
  if (!process.env.OPENAI_API_KEY) return null;
  const sys = `Eres un parser de prompts para generar playlists de Spotify. Devuelve SOLO JSON válido:
{
  "isEvent": boolean,
  "event": { "name": string, "years": number[] } | null,
  "intent": "event" | "genre" | "mood" | "artists" | "generic",
  "targetGenres": string[],
  "moodKeywords": string[],
  "mustArtists": string[],
  "mustTracks": [{"track":string,"artist":string}][],
  "count": number|null,
  "searchQueries": string[]
}`;
  const user = `Prompt: """${promptRaw}"""`;
  const r = await fetch("https://api.openai.com/v1/chat/completions",{
    method:"POST",
    headers:{ "content-type":"application/json", Authorization:`Bearer ${process.env.OPENAI_API_KEY}` },
    body:JSON.stringify({
      model: process.env.OPENAI_MODEL || "gpt-4o-mini",
      temperature: 0.2,
      messages:[{role:"system",content:sys},{role:"user",content:user}],
      response_format:{ type:"json_object" }
    })
  });
  if(!r.ok) return null;
  const data = await r.json().catch(()=>null);
  const txt = data?.choices?.[0]?.message?.content?.trim();
  if(!txt) return null;
  try { return JSON.parse(txt); } catch { return null; }
}

/** ► NUEVO: heurística local para eventos (sin IA) */
function guessEventFromPrompt(promptRaw="") {
  const w = onlyWords(promptRaw).filter(x => !STOP.has(x));
  const yrs = w.map(x => parseInt(x,10)).filter(n => n>=1990 && n<=2035);
  // toma pares/triadas prominentes (ej: "groove pamplona")
  const lower = norm(promptRaw);
  const likely = [];
  // heurísticas simples español/inglés
  if (/\bfestival|cartel|line.?up|prepararme para\b/.test(lower)) {
    // intenta coger 2-3 palabras significativas consecutivas
    const filtered = w.filter(x => x.length>2 && !String(x).match(/^\d+$/));
    for (let i=0;i<filtered.length-1;i++){
      likely.push(`${filtered[i]} ${filtered[i+1]}`);
      if (i<filtered.length-2) likely.push(`${filtered[i]} ${filtered[i+1]} ${filtered[i+2]}`);
    }
  }
  // escoge la mejor candidata: la que más se repite en el texto
  let best = "";
  let bestScore = 0;
  for (const cand of likely){
    const t = cand.split(/\s+/).map(norm).filter(Boolean);
    const sc = t.reduce((acc,tk)=>acc + (lower.includes(tk)?1:0),0);
    if (sc > bestScore) { best = cand; bestScore = sc; }
  }
  if (!best) {
    // fallback: dos palabras fuertes (sin números) al final del prompt
    const sig = w.filter(x=>x.length>2 && !/^\d+$/.test(x));
    if (sig.length>=2) best = `${sig[sig.length-2]} ${sig[sig.length-1]}`;
  }
  if (!best.trim()) return null;
  // tokens del nombre (para exigir ambos)
  const tokens = onlyWords(best).map(norm).filter(x=>x.length>2);
  return { name: best.trim(), years: Array.from(new Set(yrs)), tokens };
}

/** ► NUEVO: expandir términos desde LLM/heurística */
function expandTermsFromPlan(plan, fallbackName="") {
  const terms = new Set();
  const name = plan?.event?.name || fallbackName || "";
  const years = Array.isArray(plan?.event?.years) ? plan.event.years : [];
  const sq = Array.isArray(plan?.searchQueries) ? plan.searchQueries : [];
  for (const t of sq) terms.add(t);
  if (name) {
    terms.add(name);
    terms.add(`${name} lineup`);
    terms.add(`${name} cartel`);
    for (const y of years) {
      terms.add(`${name} ${y}`);
      terms.add(`${name} lineup ${y}`);
      terms.add(`${name} cartel ${y}`);
    }
  }
  return Array.from(terms).slice(0, 20);
}

/** ===== Batch infos ===== */
async function getArtistsBatch(ids, accessToken) {
  const chunks=[]; for(let i=0;i<ids.length;i+=50) chunks.push(ids.slice(i,i+50));
  const out=new Map();
  for(const c of chunks){
    const u = new URL("https://api.spotify.com/v1/artists");
    u.searchParams.set("ids", c.join(","));
    const { ok, data } = await spFetch(u, accessToken);
    if (!ok) continue;
    for (const a of data?.artists || []) out.set(a.id,{ id:a.id, genres:(a.genres||[]).map(g=>g.toLowerCase()) });
    await sleep(40);
  }
  return out;
}
async function getAudioFeaturesBatch(ids, accessToken) {
  const chunks=[]; for(let i=0;i<ids.length;i+=100) chunks.push(ids.slice(i,i+100));
  const out=new Map();
  for(const c of chunks){
    const u = new URL("https://api.spotify.com/v1/audio-features");
    u.searchParams.set("ids", c.join(","));
    const { ok, data } = await spFetch(u, accessToken);
    if (!ok) continue;
    for (const f of data?.audio_features || []) if (f?.id) out.set(f.id,f);
    await sleep(40);
  }
  return out;
}

/** ===== Baneos / scores ===== */
function computeBans(targets=[]) {
  const bans = new Set();
  for (const t of targets) for (const b of (BAN_IF_TARGETS[t]||[])) bans.add(b);
  return bans;
}
function banPenalty(artistGenres=[], bans=new Set()) {
  if (!bans.size) return 0;
  const ag = artistGenres.map(norm);
  for (const b of bans) if (ag.includes(b) || ag.some(g=>g.includes(b))) return -3;
  return 0;
}

/** ===== Cosecha desde playlists con tokens requeridos en eventos ===== */
async function harvestFromPlaylistsSmart({ baseTerm, plan, want, requiredTokens=[] }, accessToken) {
  const baseNorm = norm(plan?.event?.name || baseTerm || "");
  const terms = expandTermsFromPlan(plan, baseTerm);
  const freq = new Map();
  const checked = new Set();
  let scanned = 0;
  const MAX_PL = 50;

  const candidateTerms = (terms.length ? terms : [baseTerm]).filter(Boolean);
  for (const term of candidateTerms) {
    const sd = await search(term, "playlist", 12, accessToken);
    const pls = sd?.playlists?.items || [];
    for (const p of pls) {
      if (!p?.id || checked.has(p.id)) continue;
      checked.add(p.id);
      const meta = (await fetchPlaylistMeta(p.id, accessToken)) || p;
      const w = playlistWeight(meta, baseNorm, requiredTokens);
      if (w <= 0) continue; // descarta si no contiene todos los tokens del evento

      const tracks = await fetchPlaylistTracks(p.id, accessToken, 200);
      for (const t of tracks) {
        if (!t?.id) continue;
        const prev = freq.get(t.id);
        if (prev) { prev.count += 1; prev.weight += w; }
        else { freq.set(t.id, { track:t, count:1, weight:w }); }
      }
      scanned += 1;
      if (freq.size >= want * 8 || scanned >= MAX_PL) break;
      await sleep(60);
    }
    if (freq.size >= want * 8 || scanned >= MAX_PL) break;
  }

  const ranked = Array.from(freq.values())
    .sort((a,b)=> (b.weight!==a.weight ? b.weight-a.weight : b.count-a.count))
    .map(x=>x.track);

  return ranked.slice(0, want * 3);
}

/** ===== Handler ===== */
export async function POST(req) {
  try {
    const token = await getToken({ req, secret: process.env.NEXTAUTH_SECRET });
    if (!token?.accessToken) return NextResponse.json({ error:"no-access-token" }, { status:401 });

    const body = await req.json().catch(()=>({}));
    const userPlan = body?.plan || {};
    const want = Math.max(1, Math.min(Number(userPlan?.count || body?.count || 50), 200));
    const rawPrompt = String(userPlan?.rawPrompt || body?.prompt || "");
    const forceStrict = !!userPlan?.strict;

    // 1) Parseo LLM (si hay API) + heurística local reforzada para EVENTO
    let parsed = await parsePromptWithLLM(rawPrompt);
    const heuristic = guessEventFromPrompt(rawPrompt); // NUEVO
    if (!parsed) parsed = { intent:"generic" };

    // Si la heurística detecta evento claro, forzamos EVENT
    if (heuristic?.name) {
      parsed.isEvent = true;
      parsed.intent = "event";
      parsed.event = { name: heuristic.name, years: heuristic.years||[] };
      parsed.searchQueries = (parsed.searchQueries || []);
      // tokens requeridos para filtrar playlists
      parsed._requiredTokens = heuristic.tokens || [];
    }

    parsed._raw = rawPrompt;
    if (!Array.isArray(parsed.targetGenres)) parsed.targetGenres = [];
    if (!Array.isArray(parsed.moodKeywords)) parsed.moodKeywords = [];
    if (!Array.isArray(parsed.mustArtists)) parsed.mustArtists = [];
    if (!Array.isArray(parsed.mustTracks)) parsed.mustTracks = [];
    if (!Array.isArray(parsed.searchQueries)) parsed.searchQueries = [];

    const targets = normalizeTargets(parsed.targetGenres);
    const moods = parsed.moodKeywords.map(norm);
    const feats = computeFeatureTargets({ targets, moods });
    const bans = computeBans(targets);

    const intent = parsed.intent || (parsed.isEvent ? "event" : (targets.length ? "genre" : (moods.length ? "mood" : "generic")));
    const strategy = {
      usePlaylists: intent === "event" || intent === "genre" || intent === "mood",
      useArtistSeeds: intent === "artists",
      useRelated: intent === "artists",
      useRecs: intent !== "event",
    };

    const found = [];
    const seedTracks = [];
    const seedArtistIds = new Set();

    // 2) EVENTO: solo playlists que contengan TODOS los tokens (p.ej. "groove" y "pamplona")
    if (strategy.usePlaylists && intent === "event") {
      const requiredTokens = Array.isArray(parsed._requiredTokens) && parsed._requiredTokens.length
        ? parsed._requiredTokens
        : onlyWords(parsed?.event?.name || "").map(norm).filter(x=>x.length>2);

      const harvested = await harvestFromPlaylistsSmart({
        baseTerm: parsed.event?.name || rawPrompt,
        plan: parsed,
        want: want * 2,
        requiredTokens
      }, token.accessToken);

      for (const t of harvested) {
        if (!found.some(x => x.id===t.id)) {
          found.push(t);
          if (seedTracks.length < 5) seedTracks.push(t.id);
          if (found.length >= want) break;
        }
      }
    }

    // 3) Género/Mood/Genérico: semillas desde playlists del término clave
    if (strategy.usePlaylists && (intent === "genre" || intent === "mood" || intent === "generic")) {
      const keyTerm = (targets[0] || moods[0] || rawPrompt || "").split(/\s+/).slice(0,4).join(" ");
      if (keyTerm) {
        const harvested = await harvestFromPlaylistsSmart({ baseTerm:keyTerm, plan:parsed, want:Math.min(want,60), requiredTokens:[] }, token.accessToken);
        for (const t of harvested.slice(0,15)) { if (!seedTracks.includes(t.id)) seedTracks.push(t.id); if (seedTracks.length>=5) break; }
        for (const t of harvested.slice(0,20)) { if (!found.some(x=>x.id===t.id)) found.push(t); if (found.length>=Math.min(20,want)) break; }
      }
    }

    // 4) Candidatos exactos (del usuario/LLM)
    const candidates = Array.isArray(userPlan?.candidates) ? userPlan.candidates : parsed.mustTracks || [];
    if (found.length < want && candidates.length) {
      const step=8;
      for (let i=0; i<candidates.length && found.length<want; i+=step){
        const slice = candidates.slice(i,i+step);
        const batch = await Promise.all(slice.map(c => searchTrack({ track:c?.track, artist:c?.artist }, token.accessToken)));
        for (const t of batch) {
          if (t && !found.some(x=>x.id===t.id)) {
            found.push(t);
            if (seedTracks.length < 5) seedTracks.push(t.id);
          }
        }
        await sleep(40);
      }
    }

    // 5) Artistas obligatorios / relacionados (filtrados por mood/genre)
    if (strategy.useArtistSeeds || parsed.mustArtists.length) {
      const must = Array.from(new Set([...(parsed.mustArtists||[])])).slice(0,8);
      const mustIds = (await Promise.all(must.map(n => resolveArtistId(n, token.accessToken)))).filter(Boolean);
      for (const id of mustIds) {
        if (seedArtistIds.size < 5) seedArtistIds.add(id);
        const tops = await artistTopTracks(id, token.accessToken);
        for (const t of tops) {
          if (!found.some(x=>x.id===t.id)) found.push(t);
          if (seedTracks.length < 5 && !seedTracks.includes(t.id)) seedTracks.push(t.id);
          if (found.length >= want) break;
        }
        if (strategy.useRelated) {
          const rel = await relatedArtists(id, token.accessToken);
          for (const ra of rel.slice(0,5)) {
            if (seedArtistIds.size < 5) seedArtistIds.add(ra.id);
            const tops2 = await artistTopTracks(ra.id, token.accessToken);
            for (const t of tops2.slice(0,2)) {
              if (!found.some(x=>x.id===t.id)) found.push(t);
              if (seedTracks.length < 5 && !seedTracks.includes(t.id)) seedTracks.push(t.id);
              if (found.length >= want) break;
            }
            if (found.length >= want) break;
          }
        }
        if (found.length >= want) break;
      }
    }

    // 6) Recomendaciones para completar (no evento, o como relleno)
    if (strategy.useRecs && (seedTracks.length || seedArtistIds.size) && found.length < want) {
      const recs = await recommendations({ seedTracks, seedArtists:Array.from(seedArtistIds), limit:(want-found.length), features:feats }, token.accessToken);
      for (const t of recs) {
        if (!found.some(x=>x.id===t.id)) { found.push(t); if (found.length>=want) break; }
      }
    }

    // 7) Scoring final (género+mood + penalizaciones)
    let tracks = dedupeById(found).slice(0, want*2);
    const artistIds = Array.from(new Set(tracks.flatMap(t => (t.artists||[]).map(a=>a.id)).filter(Boolean)));
    const artistsMap = await getArtistsBatch(artistIds, token.accessToken);
    const featsMap = tracks.length ? await getAudioFeaturesBatch(tracks.map(t=>t.id), token.accessToken) : new Map();

    const scored = tracks.map(t => {
      const firstArtistId = t.artists?.[0]?.id;
      const ag = firstArtistId ? (artistsMap.get(firstArtistId)?.genres || []) : [];
      const gScore = targets.length ? artistGenreScore(ag, targets) : 0;
      const fScore = featsMap.size ? featureScore(featsMap.get(t.id)||null, feats) : 0;
      const pen = banPenalty(ag, bans);
      const base = (targets.length ? gScore*2 : 0) + (Object.keys(feats).length ? fScore : 0) + pen;
      return { t, score: base };
    });

    const minScore = intent === "event" ? 1 : 0;
    scored.sort((a,b)=> b.score - a.score);
    let final = scored.filter(x=>x.score > minScore).slice(0, want).map(x=>x.t);
    if (final.length < want) {
      for (const x of scored) { if (final.length>=want) break; if (!final.some(y=>y.id===x.t.id)) final.push(x.t); }
      final = final.slice(0, want);
    }
    if (forceStrict && (targets.length || Object.keys(feats).length)) {
      const keep=[]; for (const x of scored){ if (keep.length>=want) break; if (x.score>0 && !keep.some(y=>y.t.id===x.t.id)) keep.push(x); }
      if (keep.length) final = keep.slice(0,want).map(z=>z.t);
    }

    const clean = final.map(toPublicTrack);

    // Log útil en local
    if (process.env.NODE_ENV !== "production") {
      console.log("[RECS] intent:", intent, "event:", parsed?.event, "requiredTokens:", parsed?._requiredTokens);
      console.log("[RECS] want:", want, "got:", clean.length);
    }

    return NextResponse.json({
      ok: true,
      got: clean.length,
      tracks: clean,
      plan: {
        intent,
        isEvent: !!parsed.isEvent,
        event: parsed.event || null,
        requiredTokens: parsed?._requiredTokens || [],
        targetGenres: parsed.targetGenres || [],
        moodKeywords: parsed.moodKeywords || [],
        features: feats,
        usedSeeds: { seedTracks, seedArtists: Array.from(seedArtistIds) },
      },
      source: intent === "event" ? "playlists(tokens)→filter" : "hybrid→filter",
    });
  } catch (e) {
    return NextResponse.json({ error:"server", message:String(e?.message||e) }, { status:500 });
  }
}

export const GET = POST;
