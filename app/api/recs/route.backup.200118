import { NextResponse } from "next/server";
import { getToken } from "next-auth/jwt";

const sleep = (ms)=> new Promise(r=>setTimeout(r, ms));
const norm = (s="")=> s.normalize("NFD").replace(/\p{Diacritic}/gu,"").toLowerCase().trim();

function mapTrackRaw(t){
  // Mantiene ids de artistas para scoring interno
  return {
    id: t.id,
    name: t.name,
    artists: (t.artists||[]).map(a=>({ id:a.id, name:a.name })), // <-- objetos (uso interno)
    uri: t.uri,
    open_url: t.external_urls?.spotify || `https://open.spotify.com/track/${t.id}`
  };
}

function toPublicTrack(t){
  // Convierte a formato que espera tu UI: artistas = array de nombres
  return {
    ...t,
    artists: (t.artists||[])
      .map(a => (typeof a === "string" ? a : a?.name))
      .filter(Boolean)
  };
}

function dedupe(list){
  const seen = new Set(); const res=[];
  for (const t of list){
    if (!t?.id) continue;
    if (seen.has(t.id)) continue;
    seen.add(t.id);
    res.push(t);
  }
  return res;
}

// ===== Spotify helpers =====
async function search(q, type, limit, accessToken){
  const url = new URL("https://api.spotify.com/v1/search");
  url.searchParams.set("q", q);
  url.searchParams.set("type", type);
  url.searchParams.set("limit", String(limit||5));
  url.searchParams.set("market", "from_token");
  const r = await fetch(url, { headers: { Authorization: `Bearer ${accessToken}` }, cache:"no-store" });
  if (!r.ok) return null;
  return r.json();
}

async function fetchPlaylistTracks(playlistId, accessToken, max=200){
  const out = [];
  let url = `https://api.spotify.com/v1/playlists/${playlistId}/tracks?limit=100`;
  while (url && out.length < max){
    const r = await fetch(url, { headers: { Authorization: `Bearer ${accessToken}` } });
    if (!r.ok) break;
    const d = await r.json();
    for (const it of (d?.items||[])) {
      const t = it?.track;
      if (t?.id) out.push(mapTrackRaw(t));
      if (out.length >= max) break;
    }
    url = d?.next || null;
  }
  return out;
}

async function doSearchTrack(q, accessToken){
  const d = await search(q, "track", 5, accessToken);
  const items = d?.tracks?.items || [];
  if (!items.length) return null;
  return mapTrackRaw(items[0]);
}

async function searchTrack({track, artist}, accessToken){
  const qp=[];
  if (track)  qp.push(`track:"${track.replace(/"/g,"")}"`);
  if (artist) qp.push(`artist:"${artist.replace(/"/g,"")}"`);
  const q1 = qp.join(" ") || (track||artist||"");
  let best = await doSearchTrack(q1, accessToken);
  if (best) return best;

  if (track){
    best = await doSearchTrack(track, accessToken);
    if (best) return best;
  }
  if (track || artist){
    const q3 = [artist, track].filter(Boolean).join(" ");
    best = await doSearchTrack(q3, accessToken);
    if (best) return best;
  }
  return null;
}

async function resolveArtistId(name, accessToken){
  const d = await search(`artist:"${name.replace(/"/g,"")}"`, "artist", 1, accessToken);
  const it = d?.artists?.items?.[0];
  return it?.id || null;
}

async function artistTopTracks(artistId, accessToken){
  const url = `https://api.spotify.com/v1/artists/${artistId}/top-tracks?market=ES`;
  const r = await fetch(url, { headers: { Authorization: `Bearer ${accessToken}` } });
  if (!r.ok) return [];
  const d = await r.json();
  return (d?.tracks||[]).map(mapTrackRaw);
}

async function recommendations({seedTracks=[], seedArtists=[], limit=50, genreHints=null}, accessToken){
  const url = new URL("https://api.spotify.com/v1/recommendations");
  url.searchParams.set("limit", String(Math.min(limit, 100)));
  if (seedTracks.length)  url.searchParams.set("seed_tracks", seedTracks.slice(0,5).join(","));
  if (seedArtists.length) url.searchParams.set("seed_artists", seedArtists.slice(0,5).join(","));
  const h = genreHints || {};
  for (const [k,v] of Object.entries(h)){
    url.searchParams.set(k, String(v));
  }
  const r = await fetch(url, { headers: { Authorization: `Bearer ${accessToken}` } });
  if (!r.ok) return [];
  const d = await r.json();
  return (d?.tracks||[]).map(mapTrackRaw);
}

// ===== Género: batch artists & audio-features =====
async function getArtistsBatch(ids, accessToken){
  const chunks = [];
  for (let i=0;i<ids.length;i+=50) chunks.push(ids.slice(i,i+50));
  const out = new Map();
  for (const c of chunks){
    const url = new URL("https://api.spotify.com/v1/artists");
    url.searchParams.set("ids", c.join(","));
    const r = await fetch(url, { headers: { Authorization: `Bearer ${accessToken}` } });
    if (!r.ok) continue;
    const d = await r.json();
    for (const a of (d?.artists||[])){
      out.set(a.id, { id:a.id, genres:(a.genres||[]).map(g=>g.toLowerCase()) });
    }
    await sleep(50);
  }
  return out;
}

async function getAudioFeaturesBatch(ids, accessToken){
  const chunks = [];
  for (let i=0;i<ids.length;i+=100) chunks.push(ids.slice(i,i+100));
  const out = new Map();
  for (const c of chunks){
    const url = new URL("https://api.spotify.com/v1/audio-features");
    url.searchParams.set("ids", c.join(","));
    const r = await fetch(url, { headers: { Authorization: `Bearer ${accessToken}` } });
    if (!r.ok) continue;
    const d = await r.json();
    for (const f of (d?.audio_features||[])){
      if (f?.id) out.set(f.id, f);
    }
    await sleep(50);
  }
  return out;
}

const GENRE_HINTS = {
  hardstyle: { min_tempo:150, target_energy:0.9, target_danceability:0.6 },
  nightcore: { min_tempo:160, target_energy:0.85, target_danceability:0.6 },
  phonk:     { min_tempo:90, max_tempo:140, target_energy:0.75, target_danceability:0.7 },
  techno:    { min_tempo:125, max_tempo:140, target_energy:0.8,  target_danceability:0.7 },
  "drum and bass": { min_tempo:160, max_tempo:180, target_energy:0.85, target_danceability:0.6 },
  dubstep:   { min_tempo:130, max_tempo:160, target_energy:0.85 },
  trance:    { min_tempo:130, max_tempo:145, target_energy:0.8,  target_danceability:0.6 },
  reggaeton: { min_tempo:80,  max_tempo:105, target_danceability:0.8 }
};

function normalizeTargets(targetGenres){
  const t = (targetGenres||[]).map(g=>norm(g));
  return t.map(x=> x==="dnb" ? "drum and bass" : x);
}

function genreHintsForSeeds(targets){
  for (const t of targets){
    const h = GENRE_HINTS[t];
    if (h) return h;
  }
  return null;
}

function artistGenreScore(artistGenres=[], targets=[]){
  if (!targets.length) return 0;
  const ag = artistGenres.map(norm);
  let s=0;
  for (const t of targets){
    if (ag.includes(t)) s+=3;
    else if (ag.some(g=>g.includes(t))) s+=2;
  }
  return s;
}

function featureScore(f=null, targets=[]){
  if (!f || !targets.length) return 0;
  const h = genreHintsForSeeds(targets);
  if (!h) return 0;
  let s=0;
  if (h.min_tempo && f.tempo >= h.min_tempo) s+=1;
  if (h.max_tempo && f.tempo <= h.max_tempo) s+=1;
  if (h.target_energy && Math.abs(f.energy - h.target_energy) < 0.2) s+=1;
  if (h.target_danceability && Math.abs(f.danceability - h.target_danceability) < 0.2) s+=1;
  return s;
}

async function recommendationsGenreAware({seedTracks=[], seedArtists=[], limit=50, targets=[]}, accessToken){
  const hints = genreHintsForSeeds(targets);
  return recommendations({ seedTracks, seedArtists, limit, genreHints: hints }, accessToken);
}

// ===== Harvester (eventos) =====
function buildEventTerms(rawPrompt="", queryTerms=[]){
  const terms = new Set();
  const p = rawPrompt.trim();
  if (p) terms.add(p);
  for (const t of (queryTerms||[])) if (t && t.length>=3) terms.add(t);
  const base = p.replace(/\b20\d{2}\b/g,"").trim();
  if (base) terms.add(base);
  const low = base.toLowerCase();
  if (low) terms.add(low);
  return Array.from(terms).slice(0,8);
}

async function harvestFromPlaylistsSmart({rawPrompt, queryTerms, want}, accessToken){
  const terms = buildEventTerms(rawPrompt, queryTerms);
  const freq = new Map(); // id -> {track, count}
  const seenPlaylists = new Set();
  for (const term of terms){
    const sd = await search(term, "playlist", 10, accessToken);
    const pls = sd?.playlists?.items || [];
    for (const p of pls){
      if (!p?.id) continue;
      if (seenPlaylists.has(p.id)) continue;
      seenPlaylists.add(p.id);
      const tracks = await fetchPlaylistTracks(p.id, accessToken, 200);
      for (const t of tracks){
        const k = t.id;
        const prev = freq.get(k);
        if (prev) prev.count += 1;
        else freq.set(k, { track: t, count: 1 });
      }
      if (freq.size >= want*4) break;
      await sleep(60);
    }
    if (freq.size >= want*4) break;
  }
  const ranked = Array.from(freq.values()).sort((a,b)=> b.count - a.count).map(x=>x.track);
  return ranked.slice(0, want*2);
}

// ===== Handler principal =====
export async function POST(req){
  try{
    const token = await getToken({ req, secret: process.env.NEXTAUTH_SECRET });
    if (!token?.accessToken) return NextResponse.json({ error:"no-access-token" }, { status:401 });

    const { plan, count=50 } = await req.json().catch(()=>({}));
    const want = Math.max(1, Math.min(Number(plan?.count || count || 50), 200));
    const candidates = Array.isArray(plan?.candidates) ? plan.candidates : [];
    const queryTerms = Array.isArray(plan?.queryTerms) ? plan.queryTerms : [];
    const rawPrompt = String(plan?.rawPrompt || "");
    const baseIsEvent = !!plan?.isEvent;
    const targets = normalizeTargets(plan?.targetGenres || []);

    // Evento?
    const p = rawPrompt.toLowerCase();
    const looksEvent = baseIsEvent || /(festival|cartel|line[\s-]?up|lineup|riverland|primavera|mad\s?cool|boombastic|arenal|sonar|fib|o son do camiño|cruilla)/i.test(p);

    const found = [];
    const seedTracks = [];
    const seedArtistIds = new Set();

    // 0) EVENTO: primero harvester
    if (looksEvent){
      const harvested = await harvestFromPlaylistsSmart({ rawPrompt, queryTerms, want: want*2 }, token.accessToken);
      for (const t of harvested){
        if (!found.some(x=>x.id===t.id)) {
          found.push(t);
          if (seedTracks.length<5) seedTracks.push(t.id);
          if (found.length >= want) break;
        }
      }
    }

    // 1) MATCH de candidatos IA
    if (found.length < want && candidates.length){
      const pool = 8;
      let i = 0;
      while (i < candidates.length && found.length < want){
        const slice = candidates.slice(i, i+pool);
        const batch = await Promise.all(slice.map(async c=>{
          const t = await searchTrack({ track:c?.track, artist:c?.artist }, token.accessToken);
          return t || null;
        }));
        for (const t of batch){
          if (t && !found.some(x=>x.id===t.id)){
            found.push(t);
            if (seedTracks.length<5) seedTracks.push(t.id);
          }
        }
        i += pool;
        await sleep(60);
      }
    }

    // 2) Top-tracks por artista
    if (found.length < want && candidates.length){
      const artistNames = Array.from(new Set(candidates.map(c=>String(c?.artist||"").trim()).filter(Boolean))).slice(0,10);
      const ids = await Promise.all(artistNames.map(n=>resolveArtistId(n, token.accessToken)));
      for (const id of ids.filter(Boolean)){
        if (seedArtistIds.size<5) seedArtistIds.add(id);
        if (found.length >= want) break;
        const tops = await artistTopTracks(id, token.accessToken);
        for (const t of tops){
          if (!found.some(x=>x.id===t.id)){
            found.push(t);
            if (seedTracks.length<5) seedTracks.push(t.id);
            if (found.length >= want) break;
          }
        }
      }
    }

    // 3) Recommendations con hints de género
    if (found.length < want && (seedTracks.length || seedArtistIds.size)){
      const recs = await recommendations({
        seedTracks,
        seedArtists: Array.from(seedArtistIds),
        limit: want - found.length,
        genreHints: (()=>{
          for (const t of targets){ if (GENRE_HINTS[t]) return GENRE_HINTS[t]; }
          return null;
        })()
      }, token.accessToken);
      for (const t of recs){
        if (!found.some(x=>x.id===t.id)){
          found.push(t);
          if (found.length >= want) break;
        }
      }
    }

    // ===== Filtro/rerank por género y audio-features =====
    let tracks = dedupe(found);

    // Batch artistas
    const artistIds = Array.from(new Set(tracks.flatMap(t => (t.artists||[]).map(a=>a.id)).filter(Boolean)));
    const artistsMap = await getArtistsBatch(artistIds, token.accessToken);

    // Batch audio-features (si hay targets)
    let featsMap = new Map();
    if (targets.length){
      const trackIds = tracks.map(t=>t.id);
      featsMap = await getAudioFeaturesBatch(trackIds, token.accessToken);
    }

    const scored = tracks.map(t=>{
      const firstArtistId = t.artists?.[0]?.id;
      const ag = firstArtistId ? (artistsMap.get(firstArtistId)?.genres || []) : [];
      const gScore = artistGenreScore(ag, targets);
      const fScore = (featsMap.size ? featureScore(featsMap.get(t.id) || null, targets) : 0);
      return { t, score: gScore*2 + fScore };
    });

    scored.sort((a,b)=> b.score - a.score);
    const filtered = targets.length ? scored.filter(x=> x.score > 0) : scored;

    let final = filtered.slice(0, want).map(x=>x.t);
    if (final.length < want){
      for (const x of scored){
        if (final.length >= want) break;
        if (!final.some(y=>y.id===x.t.id)) final.push(x.t);
      }
      final = final.slice(0, want);
    }

    // *** IMPORTANTE: devolver artistas como NOMBRES ***
    const clean = final.map(toPublicTrack);

    return NextResponse.json({
      ok:true,
      got: clean.length,
      tracks: clean,
      source: looksEvent ? "harvest-first" : "ai-first",
      targets
    });
  }catch(e){
    return NextResponse.json({ error:"server", message:String(e?.message||e) }, { status:500 });
  }
}

export const GET = POST;
