import { NextResponse } from "next/server";
import { getToken } from "next-auth/jwt";

const sleep = (ms)=> new Promise(r=>setTimeout(r, ms));

function norm(s=""){ return s.normalize("NFD").replace(/\p{Diacritic}/gu,"").toLowerCase().trim(); }
function scoreMatch(trackName, artistNames, wantTrack, wantArtist){
  // Puntuación sencilla: +2 si coincide artista exacto, +1 si contiene, +1 si el título contiene
  let s=0;
  const nt=norm(trackName), na = artistNames.map(norm);
  const wt = norm(wantTrack||""), wa = norm(wantArtist||"");
  if (wa && na.includes(wa)) s+=2;
  if (wa && na.some(a=>a.includes(wa))) s+=1;
  if (wt && nt.includes(wt)) s+=1;
  return s;
}

function mapTrack(t){
  return {
    id: t.id,
    name: t.name,
    artists: (t.artists||[]).map(a=>a.name),
    uri: t.uri,
    open_url: t.external_urls?.spotify || `https://open.spotify.com/track/${t.id}`
  };
}

async function searchTrack({track, artist}, accessToken){
  // Intento 1: query precisa con comillas
  const qp = [];
  if (track)  qp.push(`track:"${track.replace(/"/g,"")}"`);
  if (artist) qp.push(`artist:"${artist.replace(/"/g,"")}"`);
  const q1 = qp.join(" ") || (track||artist||"");
  let best = await doSearch(q1, accessToken);
  if (best) return best;

  // Intento 2: track suelto
  if (track){
    best = await doSearch(track, accessToken);
    if (best) return best;
  }
  // Intento 3: artista + track sin comillas
  if (track || artist){
    const q3 = [artist, track].filter(Boolean).join(" ");
    best = await doSearch(q3, accessToken);
    if (best) return best;
  }
  return null;
}

async function doSearch(q, accessToken){
  const url = new URL("https://api.spotify.com/v1/search");
  url.searchParams.set("q", q);
  url.searchParams.set("type", "track");
  url.searchParams.set("limit", "5");
  url.searchParams.set("market", "from_token");
  const r = await fetch(url, { headers: { Authorization: `Bearer ${accessToken}` }, cache: "no-store" });
  if (!r.ok) return null;
  const data = await r.json();
  const items = data?.tracks?.items || [];
  if (!items.length) return null;
  // escoge por score
  let best=null, bestScore=-1;
  for (const it of items){
    const sc = scoreMatch(it.name, (it.artists||[]).map(a=>a.name), q, "");
    if (sc>bestScore){ bestScore=sc; best=it; }
  }
  return best ? mapTrack(best) : null;
}

async function resolveArtistId(name, accessToken){
  const url = new URL("https://api.spotify.com/v1/search");
  url.searchParams.set("q", `artist:"${name.replace(/"/g,"")}"`);
  url.searchParams.set("type", "artist");
  url.searchParams.set("limit", "1");
  const r = await fetch(url, { headers: { Authorization: `Bearer ${accessToken}` } });
  if (!r.ok) return null;
  const d = await r.json();
  const it = d?.artists?.items?.[0];
  return it?.id || null;
}

async function artistTopTracks(artistId, accessToken){
  // país from_token no existe aquí; usa ES como heurística para MVP
  const url = `https://api.spotify.com/v1/artists/${artistId}/top-tracks?market=ES`;
  const r = await fetch(url, { headers: { Authorization: `Bearer ${accessToken}` } });
  if (!r.ok) return [];
  const d = await r.json();
  return (d?.tracks||[]).map(mapTrack);
}

async function recommendations({seedTracks=[], seedArtists=[], limit=50}, accessToken){
  const url = new URL("https://api.spotify.com/v1/recommendations");
  url.searchParams.set("limit", String(Math.min(limit, 100)));
  if (seedTracks.length)  url.searchParams.set("seed_tracks", seedTracks.slice(0,5).join(","));
  if (seedArtists.length) url.searchParams.set("seed_artists", seedArtists.slice(0,5).join(","));
  const r = await fetch(url, { headers: { Authorization: `Bearer ${accessToken}` } });
  if (!r.ok) return [];
  const d = await r.json();
  return (d?.tracks||[]).map(mapTrack);
}

async function harvestFromPlaylists(queryTerms, accessToken, need){
  // Busca playlists públicas por los términos y saca sus pistas
  const terms = (queryTerms||[]).slice(0,3).join(" ");
  if (!terms) return [];
  const url = new URL("https://api.spotify.com/v1/search");
  url.searchParams.set("q", terms);
  url.searchParams.set("type", "playlist");
  url.searchParams.set("limit", "5");
  const s = await fetch(url, { headers: { Authorization: `Bearer ${accessToken}` } });
  if (!s.ok) return [];
  const sd = await s.json();
  const pls = sd?.playlists?.items || [];
  const out = [];
  for (const p of pls){
    const r = await fetch(`https://api.spotify.com/v1/playlists/${p.id}/tracks?limit=100`, {
      headers: { Authorization: `Bearer ${accessToken}` }
    });
    if (!r.ok) continue;
    const d = await r.json();
    const items = d?.items || [];
    for (const it of items){
      const t = it.track;
      if (t?.id) out.push(mapTrack(t));
      if (out.length >= need) break;
    }
    if (out.length >= need) break;
  }
  return out;
}

function dedupe(list){
  const seen = new Set(); const res = [];
  for (const t of list){
    if (!t?.id) continue;
    if (seen.has(t.id)) continue;
    seen.add(t.id); res.push(t);
  }
  return res;
}

export async function POST(req){
  try{
    const token = await getToken({ req, secret: process.env.NEXTAUTH_SECRET });
    if (!token?.accessToken) return NextResponse.json({ error:"no-access-token" }, { status:401 });

    const { plan, count=50 } = await req.json().catch(()=>({}));
    const want = Math.max(1, Math.min(Number(plan?.count || count || 50), 200));
    const candidates = Array.isArray(plan?.candidates) ? plan.candidates : [];
    const queryTerms = Array.isArray(plan?.queryTerms) ? plan.queryTerms : [];
    const isEvent = !!plan?.isEvent;

    const found = [];
    const seedTracks = [];
    const seedArtistIds = new Set();

    // ---- 1) MATCH de candidatos con concurrencia (pool=8) ----
    const pool = 8;
    let i = 0;
    while (i < candidates.length && found.length < want){
      const slice = candidates.slice(i, i+pool);
      const batch = await Promise.all(slice.map(async c=>{
        const tr = await searchTrack({ track: c?.track, artist: c?.artist }, token.accessToken);
        if (tr) return tr;
        return null;
      }));
      for (const t of batch){
        if (t && !found.some(x=>x.id===t.id)){
          found.push(t);
          if (seedTracks.length<5) seedTracks.push(t.id);
        }
      }
      i += pool;
      // micro pausa para no golpear demasiado
      await sleep(80);
    }

    // ---- 2) Si faltan, usar artistas de candidatos para top-tracks ----
    if (found.length < want && candidates.length){
      // resuelve ids de hasta 10 artistas distintos
      const artistNames = Array.from(new Set(candidates.map(c=>String(c?.artist||"").trim()).filter(Boolean))).slice(0,10);
      const ids = await Promise.all(artistNames.map(n=>resolveArtistId(n, token.accessToken)));
      for (const id of ids.filter(Boolean)){
        if (seedArtistIds.size<5) seedArtistIds.add(id);
        if (found.length >= want) break;
        const tops = await artistTopTracks(id, token.accessToken);
        for (const t of tops){
          if (!found.some(x=>x.id===t.id)){
            found.push(t);
            if (seedTracks.length<5) seedTracks.push(t.id);
            if (found.length >= want) break;
          }
        }
      }
    }

    // ---- 3) Si aún faltan, recommendations con seeds ----
    if (found.length < want && (seedTracks.length || seedArtistIds.size)){
      const recs = await recommendations({
        seedTracks,
        seedArtists: Array.from(seedArtistIds),
        limit: want - found.length
      }, token.accessToken);
      for (const t of recs){
        if (!found.some(x=>x.id===t.id)){
          found.push(t);
          if (found.length >= want) break;
        }
      }
    }

    // ---- 4) Si huele a EVENTO o seguimos muy cortos, harvester desde playlists ----
    if ((isEvent || found.length < Math.min(50, want)) && queryTerms.length){
      const need = want - found.length;
      if (need > 0){
        const harvested = await harvestFromPlaylists(queryTerms, token.accessToken, need);
        for (const t of harvested){
          if (!found.some(x=>x.id===t.id)){
            found.push(t);
            if (found.length >= want) break;
          }
        }
      }
    }

    const tracks = dedupe(found).slice(0, want);
    return NextResponse.json({ ok:true, got: tracks.length, tracks });
  }catch(e){
    return NextResponse.json({ error:"server", message:String(e?.message||e) }, { status:500 });
  }
}

export const GET = POST;
