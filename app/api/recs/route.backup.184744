import { NextResponse } from "next/server";
import { getToken } from "next-auth/jwt";

const uniqBy = (arr, keyFn) => {
  const seen = new Set(); const out = [];
  for (const x of arr) { const k = keyFn(x); if (!seen.has(k)) { seen.add(k); out.push(x); } }
  return out;
};

const mapTrack = (t) => ({
  id: t.id,
  name: t.name,
  artists: (t.artists || []).map(a => a.name).join(", "),
  uri: t.uri,
  open_url: `https://open.spotify.com/track/${t.id}`,
});

export async function POST(req) {
  try {
    const token = await getToken({ req, secret: process.env.NEXTAUTH_SECRET });
    if (!token?.accessToken) return NextResponse.json({ error: "no-access-token" }, { status: 401 });

    const { plan, page = 1, pageSize = 50 } = await req.json();
    const queries = Array.isArray(plan?.queries) && plan.queries.length ? plan.queries : ["pop"];
    const limit = Math.max(1, Math.min(Number(pageSize) || 50, 50)); // máx 50 por búsqueda

    const perQ = Math.max(1, Math.floor(limit / Math.min(queries.length, 5)));
    let tracks = [];

    for (let i = 0; i < queries.length && tracks.length < limit; i++) {
      const q = queries[(page - 1 + i) % queries.length];
      const url = new URL("https://api.spotify.com/v1/search");
      url.searchParams.set("q", q);
      url.searchParams.set("type", "track");
      url.searchParams.set("limit", String(perQ));
      url.searchParams.set("market", "from_token");

      const r = await fetch(url, { headers: { Authorization: `Bearer ${token.accessToken}` }, cache: "no-store" });
      if (!r.ok) continue;
      const body = await r.json();
      const items = body?.tracks?.items || [];
      tracks.push(...items.map(mapTrack));
    }

    tracks = uniqBy(tracks, t => t.id);

    // filtros opcionales via audio-features
    const hasF = plan?.filters && (
      plan.filters.min_energy != null || plan.filters.max_energy != null ||
      plan.filters.min_danceability != null || plan.filters.max_danceability != null ||
      plan.filters.min_valence != null || plan.filters.max_valence != null
    );

    if (hasF && tracks.length) {
      const ids = tracks.map(t => t.id).slice(0, 100);
      const featsUrl = new URL("https://api.spotify.com/v1/audio-features");
      featsUrl.searchParams.set("ids", ids.join(","));
      const rf = await fetch(featsUrl, { headers: { Authorization: `Bearer ${token.accessToken}` } });
      if (rf.ok) {
        const feats = await rf.json();
        const byId = new Map(); (feats?.audio_features || []).forEach(f => f && byId.set(f.id, f));
        const f = plan.filters;
        const inR = (v, mn, mx) => (mn==null || v>=mn) && (mx==null || v<=mx);
        tracks = tracks.filter(x => {
          const af = byId.get(x.id);
          if (!af) return true;
          return inR(af.energy, f.min_energy, f.max_energy)
              && inR(af.danceability, f.min_danceability, f.max_danceability)
              && inR(af.valence, f.min_valence, f.max_valence);
        });
      }
    }

    tracks = tracks.slice(0, limit);
    return NextResponse.json({ ok: true, page, pageSize: limit, got: tracks.length, tracks });
  } catch (e) {
    return NextResponse.json({ error: "server", message: String(e?.message || e) }, { status: 500 });
  }
}

export const GET = POST;
