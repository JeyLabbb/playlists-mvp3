import { NextResponse } from "next/server";
import { getToken } from "next-auth/jwt";

const sleep = (ms)=> new Promise(r=>setTimeout(r, ms));
const norm = (s="")=> s.normalize("NFD").replace(/\p{Diacritic}/gu,"").toLowerCase().trim();

function mapTrack(t){
  return {
    id: t.id,
    name: t.name,
    artists: (t.artists||[]).map(a=>a.name),
    uri: t.uri,
    open_url: t.external_urls?.spotify || `https://open.spotify.com/track/${t.id}`
  };
}

function dedupe(list){
  const seen = new Set(); const res=[];
  for (const t of list){
    if (!t?.id) continue;
    if (seen.has(t.id)) continue;
    seen.add(t.id);
    res.push(t);
  }
  return res;
}

// ---- Spotify helpers ----
async function search(q, type, limit, accessToken){
  const url = new URL("https://api.spotify.com/v1/search");
  url.searchParams.set("q", q);
  url.searchParams.set("type", type);
  url.searchParams.set("limit", String(limit||5));
  url.searchParams.set("market", "from_token");
  const r = await fetch(url, { headers: { Authorization: `Bearer ${accessToken}` }, cache:"no-store" });
  if (!r.ok) return null;
  return r.json();
}

async function fetchPlaylistTracks(playlistId, accessToken, max=150){
  const out = [];
  let url = `https://api.spotify.com/v1/playlists/${playlistId}/tracks?limit=100`;
  while (url && out.length < max){
    const r = await fetch(url, { headers: { Authorization: `Bearer ${accessToken}` } });
    if (!r.ok) break;
    const d = await r.json();
    for (const it of (d?.items||[])) {
      const t = it?.track;
      if (t?.id) out.push(mapTrack(t));
      if (out.length >= max) break;
    }
    url = d?.next || null;
  }
  return out;
}

// ---- Matching de candidatos IA ----
function scoreMatch(trackName, artistNames, wantTrack, wantArtist){
  let s=0;
  const nt=norm(trackName), na = artistNames.map(norm);
  const wt = norm(wantTrack||""), wa = norm(wantArtist||"");
  if (wa && na.includes(wa)) s+=2;
  if (wa && na.some(a=>a.includes(wa))) s+=1;
  if (wt && nt.includes(wt)) s+=1;
  return s;
}

async function doSearchTrack(q, accessToken){
  const d = await search(q, "track", 5, accessToken);
  const items = d?.tracks?.items || [];
  if (!items.length) return null;
  // pick first (ya venimos con q ajustado)
  return mapTrack(items[0]);
}

async function searchTrack({track, artist}, accessToken){
  // Intento 1: comillas
  const qp=[];
  if (track)  qp.push(`track:"${track.replace(/"/g,"")}"`);
  if (artist) qp.push(`artist:"${artist.replace(/"/g,"")}"`);
  const q1 = qp.join(" ") || (track||artist||"");
  let best = await doSearchTrack(q1, accessToken);
  if (best) return best;

  // Intento 2: track suelto
  if (track){
    best = await doSearchTrack(track, accessToken);
    if (best) return best;
  }
  // Intento 3: artista + track sin comillas
  if (track || artist){
    const q3 = [artist, track].filter(Boolean).join(" ");
    best = await doSearchTrack(q3, accessToken);
    if (best) return best;
  }
  return null;
}

async function resolveArtistId(name, accessToken){
  const d = await search(`artist:"${name.replace(/"/g,"")}"`, "artist", 1, accessToken);
  const it = d?.artists?.items?.[0];
  return it?.id || null;
}

async function artistTopTracks(artistId, accessToken){
  const url = `https://api.spotify.com/v1/artists/${artistId}/top-tracks?market=ES`;
  const r = await fetch(url, { headers: { Authorization: `Bearer ${accessToken}` } });
  if (!r.ok) return [];
  const d = await r.json();
  return (d?.tracks||[]).map(mapTrack);
}

async function recommendations({seedTracks=[], seedArtists=[], limit=50}, accessToken){
  const url = new URL("https://api.spotify.com/v1/recommendations");
  url.searchParams.set("limit", String(Math.min(limit, 100)));
  if (seedTracks.length)  url.searchParams.set("seed_tracks", seedTracks.slice(0,5).join(","));
  if (seedArtists.length) url.searchParams.set("seed_artists", seedArtists.slice(0,5).join(","));
  const r = await fetch(url, { headers: { Authorization: `Bearer ${accessToken}` } });
  if (!r.ok) return [];
  const d = await r.json();
  return (d?.tracks||[]).map(mapTrack);
}

// ---- Harvester desde playlists públicas (eventos/actualidad) ----
function buildEventTerms(rawPrompt="", queryTerms=[]){
  const terms = new Set();
  const p = rawPrompt.trim();
  if (p) terms.add(p);
  for (const t of (queryTerms||[])) if (t && t.length>=3) terms.add(t);

  // extra: quitar años y generar variantes
  const base = p.replace(/\b20\d{2}\b/g,"").trim();
  if (base) terms.add(base);
  // variantes simples en minúscula
  const low = base.toLowerCase();
  if (low) terms.add(low);
  return Array.from(terms).slice(0,8);
}

async function harvestFromPlaylistsSmart({rawPrompt, queryTerms, want}, accessToken){
  const terms = buildEventTerms(rawPrompt, queryTerms);
  const freq = new Map(); // id -> {track, count}
  const seenPlaylists = new Set();
  for (const term of terms){
    const sd = await search(term, "playlist", 6, accessToken);
    const pls = sd?.playlists?.items || [];
    for (const p of pls){
      if (!p?.id) continue;
      if (seenPlaylists.has(p.id)) continue;
      seenPlaylists.add(p.id);
      const tracks = await fetchPlaylistTracks(p.id, accessToken, 150);
      for (const t of tracks){
        const k = t.id;
        const prev = freq.get(k);
        if (prev) prev.count += 1;
        else freq.set(k, { track: t, count: 1 });
      }
      if (freq.size >= want*3) break; // suficiente material
      await sleep(80);
    }
    if (freq.size >= want*3) break;
  }
  // Ordena por frecuencia (pistas que aparecen en más playlists relacionadas)
  const ranked = Array.from(freq.values()).sort((a,b)=> b.count - a.count).map(x=>x.track);
  return ranked.slice(0, want);
}

// ---- Handler principal ----
export async function POST(req){
  try{
    const token = await getToken({ req, secret: process.env.NEXTAUTH_SECRET });
    if (!token?.accessToken) return NextResponse.json({ error:"no-access-token" }, { status:401 });

    const { plan, count=50 } = await req.json().catch(()=>({}));
    const want = Math.max(1, Math.min(Number(plan?.count || count || 50), 200));
    const candidates = Array.isArray(plan?.candidates) ? plan.candidates : [];
    const queryTerms = Array.isArray(plan?.queryTerms) ? plan.queryTerms : [];
    const rawPrompt = String(plan?.rawPrompt || "");
    const baseIsEvent = !!plan?.isEvent;

    // Heurística local por si no marcó evento
    const p = rawPrompt.toLowerCase();
    const looksEvent = baseIsEvent || /(festival|cartel|line[\s-]?up|lineup|riverland|primavera|mad\s?cool|boombastic|arenal|sonar|fib|o son do camiño|cruilla)/i.test(p);

    const found = [];
    const seedTracks = [];
    const seedArtistIds = new Set();

    // ---- 0) Si es EVENTO, primero harvester por popularidad ----
    if (looksEvent){
      const harvested = await harvestFromPlaylistsSmart({ rawPrompt, queryTerms, want: want*2 }, token.accessToken);
      for (const t of harvested){
        if (!found.some(x=>x.id===t.id)) {
          found.push(t);
          if (seedTracks.length<5) seedTracks.push(t.id);
          if (found.length >= want) break;
        }
      }
    }

    // ---- 1) MATCH de candidatos IA en paralelo (si aún faltan) ----
    if (found.length < want && candidates.length){
      const pool = 8;
      let i = 0;
      while (i < candidates.length && found.length < want){
        const slice = candidates.slice(i, i+pool);
        const batch = await Promise.all(slice.map(async c=>{
          const t = await searchTrack({ track:c?.track, artist:c?.artist }, token.accessToken);
          return t || null;
        }));
        for (const t of batch){
          if (t && !found.some(x=>x.id===t.id)){
            found.push(t);
            if (seedTracks.length<5) seedTracks.push(t.id);
          }
        }
        i += pool;
        await sleep(60);
      }
    }

    // ---- 2) Top-tracks por artista (si faltan) ----
    if (found.length < want && candidates.length){
      const artistNames = Array.from(new Set(candidates.map(c=>String(c?.artist||"").trim()).filter(Boolean))).slice(0,10);
      const ids = await Promise.all(artistNames.map(n=>resolveArtistId(n, token.accessToken)));
      for (const id of ids.filter(Boolean)){
        if (seedArtistIds.size<5) seedArtistIds.add(id);
        if (found.length >= want) break;
        const tops = await artistTopTracks(id, token.accessToken);
        for (const t of tops){
          if (!found.some(x=>x.id===t.id)){
            found.push(t);
            if (seedTracks.length<5) seedTracks.push(t.id);
            if (found.length >= want) break;
          }
        }
      }
    }

    // ---- 3) Recommendations con seeds (si faltan) ----
    if (found.length < want && (seedTracks.length || seedArtistIds.size)){
      const recs = await recommendations({
        seedTracks,
        seedArtists: Array.from(seedArtistIds),
        limit: want - found.length
      }, token.accessToken);
      for (const t of recs){
        if (!found.some(x=>x.id===t.id)){
          found.push(t);
          if (found.length >= want) break;
        }
      }
    }

    const tracks = dedupe(found).slice(0, want);
    return NextResponse.json({ ok:true, got: tracks.length, tracks, source: looksEvent ? "harvest-first" : "ai-first" });
  }catch(e){
    return NextResponse.json({ error:"server", message:String(e?.message||e) }, { status:500 });
  }
}

export const GET = POST;
